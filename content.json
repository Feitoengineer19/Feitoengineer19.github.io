{"pages":[{"title":"CATEGORIES","text":"","link":"/categories/index.html"},{"title":"TAGS","text":"","link":"/tags/index.html"}],"posts":[{"title":"學會 Markdown 開始寫部落格吧！","text":"第一篇當然要寫 Markdown 啊！不然怎麼寫部落格？ 什麼是 Markdown ？Markdown 是一種輕量化的標記語言（lightweight markup language），檔案格式為 .md，它撰寫容易，易讀性也高，能幫助作者更專注於寫作，被泛用在 Blog 或 text format，甚至被拿來撰寫電子書。常見的網站如 GitHub 或 Wordpress 都能夠用 Markdown 來撰寫文件。 更多基本介紹請見 Wikipedia 基本格式簡介標題123456用 # 加在標題文字前，例如 ###### 表示 H6 # This is heading1 ## This is heading 2...###### This is heading 6 This is heading 1This is heading 2… This is heading 6 文體1234567斜體；用 * 或 _ 將文字包起來，例如：*斜體* 或 _J個也是斜體_粗體；用 ** 把文字包起來，例如：**粗粗的粗體**刪除：用 ~~ ~~ 把不是重點的文字刪掉！ 例如： ~~ 那幹嘛寫啊？ ~~斜體＋粗體？ ***當然沒有問題！*** 斜體：斜體 或 J個也是斜體 粗體：粗粗的粗體 刪除：那幹嘛寫啊？ 斜體＋粗體？ 當然沒有問題！ 列點12345678910111. 這是有序列點第 1 點2. 這是有序列點第 2 點 1. 列點下再縮排一個 TAB 就會變成巢狀列點囉！ 2. 其實前面用什麼數字都沒關係，只要是數字就好。無序列點可以用 * 或 + 或 - 來點示：* 無序列點第 1 點+ 無序列點第 2 點 - 當然 TAB 縮排成巢狀也沒問題！ - 如果要斷行的話要在後面加上兩個空白喔 這行其實已經斷行了，但還是在同一個列點段落中。 這是有序列點第 1 點 這是有序列點第 2 點 列點下再縮排一個 TAB就會變成巢狀列點囉！（看起來很有條理？） 其實前面用什麼數字都沒關係，只要是數字就好。 無序列點可以用 * 或 + 或 - 來表示： 無序列點第 1 點 無序列點第 2 點 當然 TAB 縮排成巢狀也沒問題！ 如果要斷行的話要在後面加上兩個空白喔這行其實已經斷行了，但還是在同一個列點段落中。 引述123456&gt; 開頭加上 &gt; 就是引述囉！&gt; 只要開頭加上 &gt; 的地方都是引述&gt; 如果這一整段很長的話，只要開頭有一個 &gt; ，都會是引述範圍哦！對了，引述裡面**當然可以**運用其他 *文體* 語法的。&gt;&gt; 這樣就變成巢狀引述了！&gt;&gt;&gt; 不知道可以有幾層？ 開頭加上 &gt; 就是引述囉！只要開頭加上 &gt; 的地方都是引述 如果這一整段很長的話，只要開頭有一個 &gt;，都會是引述範圍哦！對了，引述裡面當然可以運用其他 文體 語法的。 這樣就變成巢狀引述了！ 不知道可以有幾層？ 連結1[連結文字](連結網址 &quot;標題文字&quot;) 如果你想貼上一個超連結，就用下面這個 ↓W3School 如果你想貼上一個假連結，那 ( ) 裡面就不要放連結。你點看看阿 → 會停留在原本的頁面 圖片1![Alt 文字](圖片連結 &quot;標題文字&quot;) 滑鼠移到圖片上會顯示標題文字！ YouTube 影片123456789用連結圖片的方式連結影片 ↓[![Alt 文字](http://img.youtube.com/vi/YOUTUBE影片ID放在這裡/0.jpg)](http://www.youtube.com/watch?v=YOUTUBE影片ID放在這裡)但上述方式無法設定圖片邊框與大小用行內 HTML 來連結影片，並設定圖片大小 ↓&lt;a href=&quot;http://www.youtube.com/watch?feature=player_embedded&amp;v=YOUTUBE影片ID放在這裡&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://img.youtube.com/vi/YOUTUBE影片ID放在這裡/0.jpg&quot; alt=&quot;圖片 ALT 文字放在這裡&quot; width=&quot;240&quot; height=&quot;180&quot; border=&quot;10&quot; /&gt;&lt;/a&gt; 點一下圖片就能夠連到影片網頁（Hexo 似乎不支援隨點隨放？） 程式碼12行內程式碼 ` &lt;div&gt;歡迎來到Fei的技術部落&lt;/div&gt; ` ，就用反引號包起來。程式碼區塊可以用 3 個反引號來圍住，在反引號後面接上語言名稱，可使語法高亮！ 行內程式碼 &lt;div&gt;歡迎來到Fei的技術部落&lt;/div&gt; ，就用反引號包起來。 123456789// 以 JavaScript 為例：var greet = function(say)&#123; greeting = say || 'Hello!!' return function(name)&#123; console.log(greeting + ' ' + name + '.') ; &#125;&#125;greet()('Fei') ; 不是所有程式語言都支援語法高量哦！ 參考資料 Markdown文件 林雨蒼 - Markdown Cheatsheet 中文版 六角學院 - Markdown 易編易讀，優雅的寫文吧！","link":"/2019/06/28/Markdown-Introduction/"},{"title":"weirdJavaScript 04：創造、提升與 undefined","text":"我們在 weirdJavaScript 01 提過： JavaScript 的執行環境不只包含你寫的 Code，因為它必須經過編譯器轉換。 所以，JavaScript 的執行脈絡到底包含哪些事情是我們不知道的？ 其中，最重要的就是 Creation 與 Hoisting 。 事實上，在你寫的 JavaScript 被執行之前，編譯器會先偷偷幫你做好兩件事情： 創造階段（Creation） 提升階段（Hoisting） Creation（創造）首先， Creation 階段指的是建立全域執行環境、this以及最外部環境。 在上一篇中我們有說明，在環域環境中：全域執行環境 = this = 外部環境。 Hoisting（提升）Creation 階段後接著進行 Hoisting 階段：JavaScript 引擎會先幫你宣告 變數 與 函式 ，其中，變數會先被定義為 undefined ，等到執行時才會真正賦值。 直接看程式碼比較好理解： 1234567var a = 'Variable would be hoisted in JS.' ;function b()&#123; console.log('Function would be hoisted in JS.') ;&#125;console.log(a) ;b() ; 上面這段程式碼執行後會依序出現： 12Variable would be hoisted in JS.Function would be hoisted in JS. 這個結果很直觀，但如果我們稍微調動一下程式碼順序： 1234567console.log(a) ;b() ;var a = 'Variable would be hoisted in JS.' ;function b()&#123; console.log('Function would be hoisted in JS.') ;&#125; 此時，執行結果會依序出現： 12undefinedFunction would be hoisted in JS. OMG !! WHY ??? 為什麼此時 a 變成 undefined ，而 function b 依然可以執行？ 因為，在 JavaScript 編譯器眼中，這段程式碼其實長這樣： 12345678910111213// var = a ; JS 偷偷先幫我們宣告變數 a 為 undefined，但它不會告訴我們，所以我們看不到這段。（第 1 行）// JS 偷偷先幫我們宣告函式，但它不會告訴我們，所以我們看不到這段。（第 2 ~ 5 行）// function b()&#123;// console.log('Function would be hoisted in JS.') ;//&#125; console.log(a) ; // undefined b() ; // Function would be hoisted in JS.a = 'Variable would be hoisted in JS.' ;function b()&#123; console.log('Function would be hoisted in JS.') ;&#125; JS 編譯器會先宣告全域執行環境裡的 Variables 與 Functions ，並儲存進電腦的記憶體中，供後續執行使用。先宣告變數與函式並存進電腦記憶體這個動作，就是 Hoisting。 不少網路上對 Hoisting 的解釋是：編譯器會將變數宣告與函式宣告「挪移」到最上方。但是。這樣的說法並不正確。 更精確的說法是：JS 引擎在執行程式碼前，會先將整個（JS檔案裡的）程式碼掃過一遍，並且只抓變數宣告和函式宣告出來，逐一存入電腦記憶體，供後續真正執行時使用。 比喻成實際狀況，就像是：小飛今天想做提拉米蘇，他得先看一次食譜（JS檔案），需要準備哪些材料（變數）？有什麼方法（函式）？腦中有個概念（存進記憶體）後，才真正開始照著食譜動手做。 所以，實際上 Code 的位置並沒有改變，只是 JS 編譯器進行 Hoisting 後，讓我們以為程式碼位置有所變動。如上面那一段程式碼呈現的。 特別要注意的是，JS 編譯器只會對變數宣告與函式宣告（Function Declaration）進行 Hoisting ，如果是以函式表達式（Function Expressions）將函式賦予變數，那麼就必須等到 JS 真正開始執行後才能呼叫該函式。如下面這段程式碼： 1234567891011121314console.log(funcDeclaration) ; // undefinedconsole.log(funcExpressions) ; // undefinedfuncExpressions() ; // undefined is not a function function funcDeclaration()&#123; console.log('Function Declaration would be hoisted in JS.') ;&#125;var funcExpressions = function()&#123; console.log('Function Expressions can not be hoisted in JS.')&#125;funcDeclaration() ; // Function Declaration would be hoisted in JS.funcExpressions() ; // Function Expressions can not be hoisted in JS.console.log(funcExpressions) ; // ƒ ()&#123; console.log(...) &#125; undefinedJS 編譯器進行 Hoisting 時，如果該變數還沒有被賦予值（Value）就直接被取用，JS 就會先賦予該變數 undefined 這個值。也就是前面所舉例的這段程式碼： 123456789console.log(a) ; // a 尚未被賦予值就被 console.log()，所以 JS 先賦予 a 為 undefined 值b() ;var a = 'Variable would be hoisted in JS.' ; // a 被賦予一個字串 'Variable would be hoisted in JS.'function b()&#123; console.log('Function would be hoisted in JS.') ;&#125;console.log(a) ; // Variable would be hoisted in JS. 之前我們曾經介紹過， undefined 屬於 JS 六種基本型別中的一種「值」（Value），意思是：「該變數存在於 JS 中，且已經被宣告，但尚未被賦予值」。儘管如此， undefined 本身還是一種值…我真搞不懂 JS 呀！ 要注意的是，如果某變數連宣告都還沒宣告過，那麼 JS 會判定該變數為 is not defined，意思是：「該變數不存在於 JS 中（因為你沒有宣告過它）」。 用程式碼比較如下： 123456console.log(a) ; // undefinedconsole.log(b) ; // b is not definedvar a = 100 ;console.log(a) ; // 100 另一個容易與 undefined 搞混的值，叫做 null，這裡簡單區別兩者。 null 也是 JS 六種基本型別的一種「值」，它的意義是：「空值」，代表這個變數已經宣告，且可能曾經有值，但現在沒有。 小飛：「那 null 等於 0 嗎？」 你可以試試看這段程式碼： 123var a = null ;console.log(a == 0) ; // false console.log(a &gt;= 0) ; // true .... ˊ&lt;_ˋ???????? 關於 null 的詳細介紹與型別比較，就等之後有機會再談囉！ 結論 創造提升（Creation &amp; Hoisting）指的是：在 JS 真正執行你寫的 Code 之前， JS 引擎會先跑過整個全域執行環境，並將 變數宣告 與 函式宣告 抓出來存進電腦記憶體，供後續真正執行時使用。 undefined 屬於 JS 基本型別的其中一種「值」（Value），意思是：「該變數存在於 JS 中，且已經被宣告，但尚未被賦予值」。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 2-10 、 2-11 MDN：Hoisting","link":"/2019/08/06/weird-JavaScript-04/"},{"title":"weirdJavaScript 02：Name / Value Pair 與物件","text":"Name/Value Pair？ Key/Value Pair？沒差啦！反正就得成雙成對。 名稱／數值配對（Name/Value Pair） A Name which maps to a unique value.The name may be fedined more than one, but only can have one value in any given context. 在執行環境中，只能存在一個名稱（Name），且該名稱只會對應到一個定義的數值（Value），即所謂的 Name/Value Pair，也有人稱為「鍵值配對」Key/Value Pair，類似 Python 中的「字典」（Dictionary）結構。 基本的 Name/Value Pair 就像這樣：1personName = 'Marisa' ; That value may be more name/value pair. 但實際上， value 可以是更多 Name/Value Pairs 的集合： 12345678peopleName = &#123; DavidFamily: 'David', LisaFamily: &#123; father: 'Ryan'. mother: 'Ann', dog: 'Murffy' &#125; &#125; ; 物件（Object） A collection of name/value pairs. 在 JavaScript 中，物件最簡單的定義就是，物件（Object）是一群 ame/value pairs 的集合。 我們用左右大括號 {} 來表示物件，一個基本的物件長這樣： 12345Taipei = &#123; Districts: 12, MetroLines: 5, touristSpot: 'Taipei 101'&#125; 因為 Name/Value Pair 中的 Value 也可以是另一組 Name/Value Pairs ，所以物件也可以是： 12345678Taipei = &#123; Districts: 12, MetroLines: 5, touristSpot: &#123; mustGo : 'Taipei 101', mustEat : ['Ding-Tai-Fung', 'bubble tea'] // Value 也可以是陣列（Array），因為陣列也屬於物件的一種。 &#125;&#125; 在上面這個範例中，最外層的 Taipei 是一個物件，內層的 touristSpot 也是一個物件。因為物件就是鍵值配對（Name/Value Pair）的集合。 更精確地說，在 JavaScript 中，資料型別分為兩類： 基本型別／原始型別（Primitive） 字串（String） 數字（Number） 布林值（Boolean） 空值（Null） 未定義（Undefined） Symbol（ES6 新增的型別） 物件型別（Object） 物件（Object） 陣列物件（Array） 函式物件（Function） 關於資料型別的詳細解釋，我們之後會提到。 結論 名稱／數值配對（鍵值配對）指的是，在一執行環境中，一個名稱只能對應到一個值，且值可能是另一個物件（鍵值配對的集合）。 物件指的是鍵值配對的集合。 在 JavaScript 中，任何一筆資料，如果不是基本型別（值），就是物件型別。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 2-7 MDN：JavaScript data types and data structures","link":"/2019/08/05/weird-JavaScript-02/"},{"title":"weirdJavaScript 03：全域環境與全域物件","text":"還記得之前提到的執行脈絡／環境（Execution Context）嗎？ 全域環境JavaScript 的全域（Global）環境，指的就是 （最）外部執行環境（Outer Environment），也是語法解析器解析 JavaScript 程式碼的地方，換句話說，你所寫的程式碼如果不在函式裡，那必然在函式外（Not in a function），即全域環境。 而全域的意思是，在全域環境所儲存的變數或函式，在其下任一（子）執行環境，都能夠直接取用那些全域變數或函式。譬如下面這段程式碼，在 function show 中，能夠抓到全域環境中宣告的變數 a 。 1234567var a = 'Hello JavaScript!!' ;function show()&#123; console.log(a) ; // 'Hello JavaScript!!'&#125;show() ; 在全域環境下，JavaScript 引擎會自動幫我們產生兩樣東西： 全域物件（Global Object） 變數 this 如上圖，我們在 Google Chrome Dev Tool 中分別輸入 window 和 this ，會發現在全域環境下，this 同樣指向 window 這個全域物件。 全域物件在不同的程式語言中有不同名稱，在瀏覽器（JavaScript 檔案）裡即是 window ，它已經儲存一些基本的函式（Function）和方法（Method）供我們使用，當然，我們也可以儲存變數在 window 這個全域物件裡面，這些被存在全域環境中的變數，就是俗稱的全域變數（Global Variable）。 譬如下面這段程式碼： 12345var a = 'Hello JavaScript!!' ;var b = function foo()&#123;return 100&#125; ;console.log(a, b) ; // 'Hello JavaScript!!' ƒ foo()&#123;return 100&#125;;console.log(window.a, window.b) ; // 'Hello JavaScript!!' ƒ foo()&#123;return 100&#125;; 既然全域物件命名為 window （視窗），就表示：每一個網頁（視窗）都是一個（全域）執行環境，互相獨立，互不干擾。 結論最後，可以用課程內這張圖來總結： 全域環境是 JS 最外層的執行環境（Outer Environment），它等於全域物件 window 。 全域環境，或說全域物件 window ，即：不在函式裡（Not in a function）。 在全域環境中，變數 this 等於全域物件 window 。 每一個網頁（視窗）都是一個 window ，互相獨立。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 2-9","link":"/2019/08/05/weird-JavaScript-03/"},{"title":"weirdJavaScript 01：語法解析、詞彙環境、執行脈絡","text":"相信你看完這篇就不會想學 JavaScript 了。 語法解析器（Syntax Parsers） A program that reads your code and determines what it does and if its grammar is valid. 語法解析器，或稱「編譯器／直譯器」（Compiler／Interpreter），會將我們所寫的程式碼轉換成電腦（硬體）能夠接收的指令。 在 JavaScript 中，語法解析器會一字一句的解析我們所寫的程式碼，並決定程式碼是否有效，或是語法上有沒有出錯。 例如 function say(){...} 這段程式碼，語法解析器會逐字解析為： f-u-n-c-t-i-o-n-空格-s-a-y-(-是否有代入參數-)-{-函式區塊內容-} 語法解析器會對照該段程式碼與該程式語言所規範的語法結構： function 名稱(參數){函式內容} ，如果都沒有語法上的錯誤，即決定這段程式碼為一個有效的函式（function）。 如果語法有誤（拼錯、漏字、順序不對等等），即會出現常見的 SyntaxError 。 JavaScript 不是一種程式語言嗎？為什麼還需要 Syntax Parser 去解析成電腦才懂的語言？因為不是所有程式語言都是電腦懂的指令碼，就 JavaScript 而言，它是屬於高階程式語言（High-level language）的一種（其他如 C 、 Java 等等），需要經由編譯器（Compiler）將其原始碼轉換成電腦可以解讀、執行的低階機器語言，即目標語言（機器碼 Machine Code）。 小結： Syntax Parsers 是一個中介轉譯器，協助我們（寫的程式碼）與電腦（韌體）溝通， 電腦（韌體）接收到的指令，其實不完全是我們寫的程式碼，而是經過 Syntax Parsers 轉譯過的指令。 詞彙環境（Lexical Environments） Where something sits physically in **the code you write. 簡單來說，詞彙環境指的是你的（某一段） Code 寫在哪裡？附近有哪些 Code ？。 程式碼的位置，決定了語法解析器如何解析你所寫的程式碼，這在 JavaScript 中尤其重要，很多JavaScript 奇怪的部分就是因為 lexical 的緣故，這在我們後面提到變數環境、函式作用域與範圍鏈（Scope Chain）時就能深刻體會到箇中奧妙。有時候我們寫的程式碼執行結果與期待不符，往往就是因為寫錯 Code 的位置（lexical）。更直白地說，我們不夠熟悉程式語言（JavaScript）解析語法的邏輯和規範。 譬如下面這段程式碼：12345var a = 100 ; var b = 100 ;console.log(a++,++b) // 結果會出現什麼？console.log(a,b) // 那這個結果會出現什麼？// 我猜你現在心裡 OS：What the ... ????? 小結： 你的（某一段） Code 寫在哪裡很重要！ 你的（某一段） Code 寫在哪裡很重要！！ 你的（某一段） Code 寫在哪裡很重要！！！ 可以說，學習一門程式語言，最核心技術面關鍵便是掌握該語言的語法結構。 執行脈絡（Execution Contexts） A wrapper to help manage the code that is running. 講到脈絡（context），這個詞，就得提到歷史社會學（Historical sociology），它最常被用來代指「（一個事件的）來龍去脈」：什麼先發生？什麼接著發生？發生的時候，客觀環境是怎麼樣？諸如此類，譬如「社會脈絡」、「歷史脈絡」等詞。 用這樣的語義去思考，程式語言中的執行脈絡（又稱「執行環境」）指的是，正在執行的 Code 所處的脈絡（上下文）為何？前面有哪些 Code ？後面接了哪些 Code ？被什麼 Code 所包覆（wrapped）？。 表面上，執行脈絡包含你所寫的、正在執行的程式碼，但，其實，它不只包含你寫的 Code ，還包含處理其他事情（do other things），因為你的 Code 事實上會經過編譯器轉換，而編譯器轉換的方式不盡然只執行你寫的 Code 。（傲嬌的編譯器？） 簡單理解 JavaScript 的執行脈絡，可以舉這個例子：在函式（function）中宣告變數（Variable）。12345678910111213141516function testA()&#123; var a = 100 ; console.log(a) ; // 這裡的 a 是多少？ testB() ;&#125; function testB()&#123; var a = 200 ; console.log(a) ; // 這裡的 a 又是多少？&#125;var a ;testA() ;console.log(a) ; // 那這裡的 a 呢？// 上述程式碼執行後的結果， a 值印出順序為何？ 結論 語法解析器：我們所寫的 JavaScript 必須經由語法解析器轉換成電腦（韌體）理解的語言，所以，語義很重要！ 詞彙環境：Code 寫的位置（語法結構）很重要！ 執行脈絡：目前執行的 Code 所處的環境／上下文是什麼？ 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 2-6","link":"/2019/08/04/weird-JavaScript-01/"},{"title":"weirdJavaScript 05：單執行緒、同步執行、非同步回呼","text":"JavaScript 本身是一門單執行緒且同步執行的高階程式語言。 單執行緒（Single Threaded） One command at a time. 單執行緒的意思是， JavaScript 一次只能做一件事情（一行指令）。 同步執行（Synchronous Execution） One at a time and in order. 同步執行的意思是， JavaScript 一次只能做一件事情，這件做完，才能做下一件，按照順序一件接著一件（逐行執行命令）。 小飛：「可是我聽過 JavaScript 有一個特色叫做 非同步（Asynchronous）耶？」 好，既然你誠心誠意發問了，我就… 非同步（Asynchronous） More than one at a time. 非同步的意思是，「同時間可以做不只一件事」。 注意！我說的不是 JavaScript。再次強調，JS 引擎是同步執行的，一次只能做一件事且按照指令順序。 那為什麼非同步會是 JavaScript 的特色呢？那是因為JavaScript 引擎可以和瀏覽器內其他引擎溝通，互相合作。 事實上，瀏覽器裡不只包含 JS 引擎，也包含負責畫面呈現的渲染引擎（Rendering Engine）、獲取伺服器資料的 請求方法（HTTP Request Methods） 等等。 而 JavaScript 引擎內有個東西叫作事件佇列（Event Queue），JS 會把需要和其他引擎合作的事件，暫時放在事件佇列裡等待處理。 這裡可以用兩個例子來說明。 ※ 例1. JS 與 Rendering Engine 合作的非同步事件 當我們在 JavaScript 中監聽一則 click 事件，因為它需要使用者點擊滑鼠來觸發事件，所以 JS 會把這個事件暫時放進事件佇列中，等到 JS 逐行跑完（全域執行環境的）指令，也就是執行堆疊（Execution Stack）為空以後，再來執行這則 click 事件（事件觸發後由 Rendering Engine 渲染畫面）。譬如下面這段程式碼： 12345678910111213141516171819// 全域執行開始console.log('start execution (time countdown starts)') function waitFiveSeconds()&#123; var endTime = 5000 + new Date().getTime() ; while(new Date() &lt; endTime)&#123;&#125; // 5 秒內不會做任何事，此時點擊網頁，click 事件不會立刻被執行，而是被放進事件佇列等待。 console.log('finished function (5 seconds passed)') ; // 函式 waitFiveSeconds 結束（結束 waitFiveSeconds 執行堆疊）&#125;function clickHandler()&#123; // 宣告 click 事件（函式） console.log('click event !') ;&#125;document.addEventListener('click',clickHandler) ; // 註冊 click 事件waitFiveSeconds() ; // 執行函式 waitFiveSeconds （建立 waitFiveSeconds 執行堆疊）console.log('finished execution') ; // 全域執行結束，開始執行事件佇列的事件（執行 clickHandler -&gt; 印出 'click event !' -&gt; 結束 clickHandler）。// 持續檢查事件佇列，若有新的事件觸發（被丟進佇列），便立即執行。 執行結果如下： 1234start execution (time countdown starts)finished function (5 seconds passed)finished executionclick event ! // 你點擊網頁（觸發 click）多少次，這裡就會有多少個 click event ! ※ 例2. JS 與 HTTP Request 合作的非同步事件 當我們在 JavaScript 中利用 HTTP Request 向伺服器發出一則資料請求，由於等待回覆（Response）必然耗時，所以 JS 會把這個請求（Request）暫時放進事件佇列中等待回覆（請求已經發出，並由 HTTP Request Methods 執行），等到 JS 逐行跑完（全域執行環境的）指令，也就是執行堆疊（Execution Stack）為空以後，再來處理伺服器 Response 的資料。 JS 會優先處理腳本中的執行堆疊，最後才執行事件佇列。 我們可以把事件佇列想像成 JS 引擎的對外窗口，每當 JS 遇到需要和其他引擎合作的事件，會將這些事件依序放進事件佇列，先專心跑完全域執行環境的程式碼後，再回頭逐一執行事件佇列裡的任務。 你也可以把事件佇列想像成一個大函式，把需要非同步執行的事件都先放進去，爾後再拿出來執行。這樣的方式，就是所謂的非同步回呼（Asynchronous Callback）。而那些JS 需要和其他引擎合作的事件（函式），或說，這些被 JS 放進事件佇列裡的事件（函式），正是一種回呼函式（Callback Function）。 用生活化的方式解釋回呼，大概就像這個情境：白白（JS）一次只能做一件事，他現在正在和客戶A講電話，突然客戶B來電，白白就寫了張MEMO（事件佇列）：「客戶A談完要打給客戶B」。下一秒客戶C又來電，於是白白又寫下：「B客戶談完後要打給C」。然後就得加班了？ 關於回呼的概念我們之後有機會再細談，回到事件佇列上。 當事件佇列裡排定的事件都處理完後，JS 也不會閒著，它會持續檢查（Continuous Check）事件佇列有沒有新的事件進來，如果有的話，就會立即處理，如 ※例1. 的程式碼。 發現了嗎？ JavaScript 這樣的執行流程，依然是同步的：一次只做一件事，這個做完再做下一個，按順序執行。 總而言之，JavaScript 本身雖然是同步的，但因為它能夠利用事件佇列與瀏覽器中的其他引擎互相溝通、分工合作，達到非同步的效果，非同步也就成為了 JS 的特色。 最後，需要特別注意的是，JS 非同步的部分，發生在 JS 引擎之外，也就是其他協作引擎所執行的。 結論 JavaScript 本身是一門單執行緒且同步執行的高階程式語言，意思是，它一次只能做一件事情，而且必須按順序執行，執行完一件才能繼續做下一件。 JavaScript 能夠利用事件佇列與瀏覽器中的其他引擎互相溝通、分工合作，利用同步達到非同步的效果，使得非同步成為 JS 的特色。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 2-13、2-18 先來看看瀏覽器內核長怎樣吧！ MDN：Callback function","link":"/2019/08/06/weird-JavaScript-05/"},{"title":"weirdJavaScript 06：呼叫函式、執行堆疊","text":"每當我們呼叫一個函式，JS 會立即建立屬於該函式的執行環境，然後堆起來（？） 呼叫（Invocation） Running a function 在 JS 中，我們以 函式名稱 加上一對 () ，來呼叫（Invoke）函式，也就是執行該函式的意思。 每當我們呼叫一個函式時，JS 會立即建立屬於該函式的執行環境（Execution Context），並執行該函式。 所以，我們可以得出一個小口訣：有事件（函式），就有執行脈絡（執行環境）。 以下面這段程式碼為例，駐記說明 JavaScript 引擎做了哪些事情。 12345678910111213141516// 建立 Global Execution Context// Creation &amp; Hoisting : 宣告 function b// Creation &amp; Hoisting : 宣告 function afunction b()&#123; console.log('Run function b.') ; // 印出 Run function b. // function b 結束，消滅 function a 的執行環境，並回到 function a。&#125;function a()&#123; b() ; // 建立 function b 的執行環境，執行 function b。 // function a 結束，消滅 function a 的執行環境，並回到 Global Execution Context。&#125;a() ; // 建立 function a 的執行環境，執行 function a 。// 消滅 Global Execution Context 執行堆疊（Execution Stacks）從上面的程式碼範例，我們可以歸納出 JS 建立執行環境的流程（順序）大致如下： Global Execution Context → function a Execution Context → function b Execution Context 建立執行環境的順序，我們可以用下面這張圖來想像： 如同圖，所謂執行堆疊，意思是 JS 所建立的執行環境，會一層一層往上疊加，堆在最上方的執行環境，即正在執行的事件（函式）。 反過來看，從上面的程式碼範例，我們同樣可以歸納出 JS 消滅執行環境的流程（順序）： function b Execution Context → function a Execution Context → Global Execution Context 當一個個事件（函式）完成後，JS 消滅執行環境的順序，也會一層一層往下移除，直到執行堆疊為空。 啊！順帶一提，還記得我上回說過：當執行堆疊為空， JS 會做什麼呢？ 對，檢視事件佇列是否有待回呼事件，若有就依序執行。 回到執行堆疊本身，我認為它是用來幫助我們理解 JS 引擎執行函式順序的概念，也就是說，它並不是真的存在於 JS 裡的一個系統，也不是一個範圍，只是我們想像出來的概念而已。 此外，我也覺得，用「堆疊」這個詞來描繪並不精確，如果用「深度」來形容似乎貼切多了，因為我們在全域中呼叫函式，在函式中呼叫另一個函式，相互呼叫，呼叫得愈多，執行深度也愈深。 這段只是我的小MurMur，往後還是會以執行堆疊來描述 JS 執行函式順序的概念。 結論 在 JavaScript 中，呼叫函式等於執行函式。 每呼叫一個函式，JS 會即刻建立屬於該函式的執行環境，並執行該函式。 執行堆疊的意思是， JS 所建立的執行環境會一層一層往上堆疊，堆在最上方的執行環境，就是正在執行的函式。 執行堆疊的概念用來幫助我們瞭解 JS 引擎執行函式的順序。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 2-14","link":"/2019/08/07/weird-JavaScript-06/"},{"title":"weirdJavaScript 07：變數環境與範圍鍊","text":"判斷變數屬於全域變數（Global Variable）還是區域變數（Local Variable），我們就得看變數宣告所在的位置，也就是變數環境。 變數環境 Where the variables live. 變數環境，指的是變數所處的位置。 先前在 weirdJavaScript 03 中，我們得到結論：全域環境，或說全域物件 window ，指的是不在函式裡（Not in a function）。 也就是說，在全域執行環境裡出現的變數，無論是否經過 var 宣告，都屬於全域變數。 以這段程式碼為例： 1234var a = 100 ; // 經過宣告的 a b = 200 ; // 未經宣告的 bvar c = a + b ; // 即便 b 未經宣告，仍可取用。console.log(a,b,c) ; // 100 200 300 ; a, b, c 都屬於全域變數 那麼區域變數呢？或許你已經猜到了。 在函式裡經過 var 宣告的變數，即屬於（該函式的）區域變數。 那麼，在函式中未經 var 宣告 的變數呢？很抱歉，它會被 JS 存進全域，成為全域變數。 我們綜合全域變數，來看下面這段程式碼： 123456789101112131415var a = 100 ; b = 200 ; function local()&#123; var m = 555 ; n = 666 ; console.log(a, b) ; // 100 200 console.log(m, n) ; // 555 666&#125;local() ;console.log(a, b, n) ; // 100 200 666 console.log(m) ; // m is not defined 在上例中，a 、 b 、 n 都屬於全域變數。 n 雖然在函式 local 中，卻因為未經宣告，而被 JS 存進全域。 既然它們都是全域變數，也就是說，我們能夠在任何執行環境中取用他們。 至於 m ，因為它被宣告在函式 local 中，屬於函式 local 的區域變數，只會存在於函式 local 的執行環境中，所以我們在全域中讀不到它，它會是 is not defined（在全域中未經宣告） 。 因此，為了避免存取上的混淆，實務上，建議所有變數都要經過 var 宣告。（現在多以 let 取代 var，請見 08 篇） 綜上所述，我們可以說：函式是區分變數環境的最小單位，執行函式所建立的執行環境，就是一個獨立的變數環境。 還記得 06 裡提到的小口訣嗎？有事件（呼叫函式），就有執行脈絡（執行環境）。 在函式內宣告的變數，只在該函式的執行環境內有效，當函式執行完畢，該區域變數也就消滅了，這就是變數在函式裡的作用域（Scope）。 範圍鍊（Scope Chain）小飛：「如果函式執行時，在執行環境中找不到它要取用的值呢？」 如果函式在執行環境中找不到必須取用的變數，JS 引擎會一層一層向外部環境（Outer Environment）找，直到全域環境（也就是最外層的外部環境）為止，這就是所謂的範圍鍊（Scope Chain）。 什麼意思？直接看下面這段程式碼。 12345678910111213var name = 'Fei' ;function b()&#123; console.log('My name is ' + name) ; // My name is Fei&#125;function a()&#123; var name = 'Bai' ; console.log('My name is ' + name) ; // My name is Bai b() ;&#125;a() ; 我們在 function a 中宣告 name = &#39;Bai&#39; ， 此時對 JS 而言，這個 name 是屬於 function a 的區域變數，和開頭第 1 行 name = &#39;Fei&#39; 所宣告的全域變數並不相同（存在電腦記憶體的位置也不同），因此第 9 行 console.log 在取用 name 時，取用的是區域變數所賦予的值 &#39;Bai&#39;，所以會印出 My name is Bai 。 接著， JS 呼叫 function b ，並執行第 4 行的 console.log，但是因為 function b 內部本身沒有宣告 name 這個變數，因此， JS 引擎會向 function b 的外部環境參考可以取用的變數 name，在此例中， function b 的外部環境即是全域執行環境，所以第 4 行 console.log 取用的會是全域變數 name 中的值 &#39;Fei&#39;，印出 My name is Fei 。 我們再來看第二個例子。 12345678910111213var name = 'Fei' ;function a()&#123; var name = 'Bai' ; function b()&#123; console.log('My name is ' + name) ; // My name is Bai &#125; b() ;&#125;a() ;b() ; // b is not defined JS 執行 function a 後，先宣告區域變數 name = &#39;Bai&#39;，再宣告 function b ，接著執行 function b ，但當它要印出第 7 行的 console.log 時，卻因為 function b 內部本身沒有宣告 name 這個變數，因此， JS 引擎會向 function b 的外部環境參考可以取用的變數 name，在此例中， function b 的外部（執行）環境為 function a ，所以第 7 行 console.log 取用的會是 function a 內的區域變數 name 的值 &#39;Bai&#39;，印出 My name is Bai 。 搭配執行堆疊的概念，我們可以用下面這張圖來解釋。 有感覺了嗎？重點在於，我們要如何判斷函式所處的外部環境？ 外部（執行）環境指的是變數或函式所處的詞彙環境（Lexical Environment）。 詞彙環境！回想一下，我們在 weirdJavaScript 01 說過，詞彙環境指的是：你寫的Code 所處的物理位置。 綜合來看，外部環境有下列兩種解釋： 變數或函式被你寫在哪裡？包覆這些 Code 的函式，就是它們的外部（執行）環境。 外部（執行）環境，就是創造該函式的執行環境（函式）。 判斷外部執行環境，有助於我們理解範圍鍊，瞭解函式如何取用、參考變數。 想一想，下面這段程式碼， console.log 會是誰？請試著用程式碼的物理位置來判斷。 12345678910111213141516var name = 'Fei' ;function a()&#123; function b()&#123; var name = 'Jay' ; c() ; &#125; function c()&#123; console.log('My name is ' + name) ; &#125; name = 'Shiba' ; b() ;&#125;a() ; 結論 變數環境指的是變數所處的位置。 在全域執行環境裡出現的變數，無論是否經過宣告 var ，都屬於全域變數。 在函式裡經過 var 宣告的變數，屬於該函式的區域變數。 在函式裡未經 var 宣告的變數，會被存進全域變數。 函式是區分變數環境的最小單位。 作用域指的是：在函式內宣告的區域變數，只在該函式的執行環境內有效。 範圍鍊指的是：JS 引擎會一層層向外部環境參照可取用的變數，直到全域環境為止。 外部（執行）環境指的是變數或函式所處的詞彙環境。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 2-15、2-16","link":"/2019/08/08/weird-JavaScript-07/"},{"title":"weirdJavaScript 12：運算子的優先性與相依性","text":"瞭解運算子的優先性與相依性，我們才知道許多種類的運算子擺在一起時，誰會先處理？從哪裡開始處理？ 優先性（Operator Precedence） Which operator function gets called first. 運算子的優先性指的是，哪一個運算子會優先被 JS 引擎呼叫執行？ 也就是說，許多運算子擺一起時， JS 會先執行擁有較高優先次序的運算子。 以算術運算子為例，很常見的「先乘除後加減」在 JS 亦如是： 123456// 乘法、除法在 JS 中的優先次序為 14 。// 加法、減法在 JS 中的優先次序為 13 。// 賦值在 JS 中的優先次序為 3 。 // 因此 4 * 5 會先被執行，而後為 3 + 20 ，得到 23 ，會後賦值給變數 num。var num = 3 + 4 * 5 ; console.log(num) ; // 23 相依性（Operator Associativity） What order operator functions get called in: Left-to-right or Right-to-left.When operator functions have the same precedence. 相依性指的是，當運算子具有相同優先性時，運算子執行的方向為何？分為兩種： 左相依性（Left-to-right） 右相依性（Right-to-left） 我們在上一篇中提到運算子執行的方向性，即相依性，用以判斷優先性相同的情境。 以賦值運算子為例，請看下方程式碼： 1234567// 賦值在 JS 中的優先次序為 3 ，屬於右相依性（從右邊開始往左邊看）。 var a = 3 , b = 4 , c = 5 ;a = b = c ; // c 會將值 5 向左賦值給 b 使其為 5，又 b 向左賦值給 a 使其為 5，以致 a、b、c 最後的值都是 5。console.log(a) ; // 5console.log(b) ; // 5console.log(c) ; // 5 結論 運算子的優先性指的是，JS 會處理擁有高優先次序的運算子。 運算子的相依性指的是，當運算子具有相同優先次序時，運算子執行的方向。 運算子的優先性與相依性可以參考 MND 所整理的表格。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 3-22","link":"/2019/08/11/weird-JavaScript-12/"},{"title":"weirdJavaScript 09：動態型別","text":"資料是程式語言之本，來談談 JavaScript 怎麼處理資料的？ 動態型別（Dynamic Typing） You don’t tell the JavaScript engine what type of data a variable holds.It would figure it out while your code is running. 動態型別指的是，我們不需要特別宣告變數的資料型別，JS 引擎執行時，會根據我們所撰寫的程式碼環境，自動判定變數的資料型別，也就是說，變數的資料型別可以輕易改變。 基於這種檢查變數型別寬鬆、容許資料型別之間隱性轉換的特性，JavaScript 屬於弱型別（Weakly Typed）程式語言。 相對而言，變數型別檢查較為嚴格，且不能任意轉換型別的語言，就屬於強型別（Strongly Typed），譬如 Java 。 什麼？你說 JavaScript 屬於 Java 的一種？？？ 以 Java 為例，我們在宣告變數時，同時會定義該變數的資料型別，就像這樣： 1234char name = 'Fei' ; // 定義該變數為字元（Text）int age = 23 ; // 定義該變數為整數（Integer）float BMI = 22.87 ; // 定義該變數為浮點數（Float）boolean isRich = false ; // 定義該變數為布林值（Boolean） 在 Java 中，不同的資料型態是不能一起運算處理的，你必須手動幫資料轉型，才能順利執行。 1234char a = '5566' ;int b = 520 ;System.out.printIn(a + b) ; // error: incompatible types: String cannot be converted to intSystem.out.printIn(Integer.parseInt(a) + b) ; // 6086 相同的程式碼，在 JavaScript 裡面可以順利執行，因為 JS 引擎接受隱性轉型，會偷偷幫你轉換資料型別。 123var a = '5566' ;var b = 520 ;console.log(a + b) ; // 5566520（String） &gt;///////&lt; 仔細觀察 JS 的宣告方式，無論我們用 var 、 let 還是 const 宣告，都只是在宣告一個變數，並沒有針對變數型別進行定義。 變數的資料型別要等到 JS 開始執行，變數被賦值後，我們才能確定變數的型別。 也就是說，在 JavaScript 中，變數（Variable）本身並沒有區分資料型別，變數的資料型別取決於值本身，只有值（Value）才有資料型別的區分，分為原始（Primitive）型別與物件（Object）型別兩大類。 請記得！變數在 JS 中的功用，只是一個代名詞，代指某一個值或物件。 結論 動態型別指的是，我們不需要特別宣告變數的資料型別，JS 會根據程式碼環境自動判定變數的資料型別。 弱型別指的是，程式引擎（語法解析器）檢查變數型別較為寬鬆、容許資料型別之間隱性轉換。 在 JavaScript 中，變數本身並沒有區分資料型別，值才有區分，分為基礎型別與物件型別兩大類，共七種值。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 3-19","link":"/2019/08/10/weird-JavaScript-09/"},{"title":"weirdJavaScript 11：運算子","text":"運算子就是用符號表示的函式。 運算子（Operators） A special function that is syntactically (written) differently.Generally operators take two parameters and return one result. 如同其他程式語言，在 JavaScript 中，運算子是一種特殊的函式，透過特殊符號來描述，且往往需要至少兩個以上的參數（Parameters）進行運算，以回傳（return）一個運算的結果。 以算術運算子中的 + 為例，請看下方程式碼： 1var a = 55 + 66 ; 大部分運算子使用的是中綴（Infix）表示法，意即用 + 串聯兩個所欲計算的參數 55 和 66 。 這段程式碼如果用 JS function 語法來表示，就像這樣（注意！只是幫助理解，請不要執行）： 1234function +(a,b)&#123; return a + b ;&#125;+(55,66) 當然，也部分運算子包括所謂前綴（Prefix）與後綴（Postfix）表示法。如下面這些範例： 123456var c = 100 ;var d = 200 ;// Prefixconsole.log(++c) ; // 101// Postfix console.log(d--) ; // 200 JavaScript 包含以下幾種功能的運算子： 賦值運算子 比較運算子 算術運算子 位元運算子（不常用） 邏輯運算子 條件運算子（又稱三元運算子） 逗點運算子 字串運算子 一元運算子 關係運算子 大家有空可以點進連結細讀 MDN 關於各種運算子的詳細介紹。 這裡我想簡單介紹幾種常見常用的運算子。 算術運算子（Arithmetic operators）算術運算子包括基本的數學運算方法，必須掌握的算術運算子如下： 1234567891011121314151617// 加法100 + 2 ; // 102// 減法100 - 2 ; // 98// 乘法100 * 2 ; // 200// 除法100 / 3 ; // 33.33333333...// 取餘數100 % 3 ; // 1// 指數2 ** 3 ; // 8// 增加（++）以及減少（--）：屬於一元運算子，根據前綴或後綴的表述方法會回傳不同結果。// 前綴增加／減少會回傳參數加／減 1 後的值：console.log(++100) ; // 101// 後綴增加／減少會將參數加／減 1 ，但回傳原本的值：console.log(100++) ; // 100 賦值運算子（Assignment operators）賦值運算子是將右方的參數賦予給左方，這個方向性很重要！ 賦值運算子可以結合算術方法，變成複合的賦值運算子。 常見如下： 12345678// 單純賦值var x = 5566 ;var y = x ;// 加法賦值var k += 100 ; // 等同於 k = k + 100 // 減法賦值var l -= 200 ; // 等同於 l = l - 200// 依此類推... 比較運算子（Comparison operators）比較運算子會由左至右依序比較傳入的參數，並根據結果回傳布林值： true 或 false。 如果比較的兩個參數資料型別不同，由於 JS 的動態型別特性，它會偷偷幫我們強制型轉（Coercion）後進行比較。 除了常見的比較運算子，等於和嚴格等於值得一提： 1234// 等於：比較兩個參數的數值是否相同？console.log(55 == 55) ; // true// 嚴格等於：比較兩個參數的數值以及資料型態是否相同？console.log(55 === '55') ; // false 實務上，我們會使用 === 來進行判斷，以避免 JS 偷偷幫我們強制型轉而產生紕漏。 邏輯運算子（Logical operators）邏輯運算子會由左至右判斷傳入的參數或運算式，並根據結果回傳一個其中一個參數，或布林值： true 或 false。 邏輯運算子常被用在條件判斷，尤其是 if 陳述句： 12345678910111213// 且（&amp;&amp;）：當參數為運算式，根據運算結果回傳布林值，若兩運算式結果皆為 true ，則回傳 true。console.log( 5 &lt; 6 &amp;&amp; 8 &lt; 2) ; // false// 或（||）：當參數為運算式，根據運算結果回傳布林值，若兩運算式其中之一為 true ，即回傳 true。console.log( 5 &lt; 6 || 8 &lt; 2) ; // true// 非（!）：若參數轉換成布林值為 true，則回傳 false。console.log(!5566) ; // false console.log(!!5566) ; // true ；表示 5566 的布林值為 true// 用於 if 陳述：if(5 &lt; 6 &amp;&amp; 6 &lt; 7)&#123; console.log('This is TRUE!') ; // This is TRUE!&#125;else&#123; console.log('This is FALSE!') ;&#125; 注意！在 JS 中，應該避免同時三個值以上的多重判斷，尤其在 if 等條件陳述中，JS 強制型轉的特色可能會導致非預期的結果： 123456// 尷尬的案例 ˊ_&gt;ˋif(3 &lt; 2 &lt; 1)&#123; console.log('This is TRUE!') ; // This is TRUE!&#125;else&#123; console.log('This is FALSE!') ;&#125; 所以，在判斷多重條件時，請使用邏輯運算子確保嚴謹： 12345if(3 &lt; 2 &amp;&amp; 2 &lt; 1)&#123; console.log('This is TRUE!') ; &#125;else&#123; console.log('This is FALSE!') ; // This is FALSE!&#125; 結論 運算子是一種透過特殊符號來表述的函式。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 3-21 MDN：Expressions and operators","link":"/2019/08/11/weird-JavaScript-11/"},{"title":"weirdJavaScript 13：強制型轉","text":"強制型轉（Coercion）， JS 偷偷幫我們處理但不告訴我們的事情之一。 強制型轉（Coercion） Converting a value from one type to another.This happens quite often in JavaScript because it’s dynamically typed. 由於 JavaScript 屬於動態型別的語言，語法對於資料型態並沒有嚴格的規範，以致型別之間的轉換相當容易，所以，當碰到不同資料型別之間的運算或判斷時，JS 會（貼心？）偷偷幫我們轉換資料型別進行判斷，這就是所謂的強制型轉。 JS 強制型轉的特色是有跡可循的，我們先從字串運算子講起。 字串運算子（String Operator）字串運算子中只有 + 這個運算子，它除了可以作為算術中的加法，還可以串起兩邊的字串。 字串運算子的重點在於，只要 + 雙邊有一個資料屬於字串，那麼另一個資料就會被強制型轉為字串，並串起兩字串。 1234567// + 串起兩字串'哈囉你好嗎？' + '衷心感謝！' ; // 哈囉你好嗎？衷心感謝！// + 串起數字與字串'55' + 66 ; // 556655 + '66' ; // 5566// + 串起布林與字串false + 'true' ; // falsetrue 注意！字串運算子只有 + 可以串起兩字串，沒有 - 這個運算子的！ 最近看到這個 JavaScript is weird 的解析結果，試著結合運算子的優先性與相依性想想看： 12('b'+'a'+ +'a'+'a').toLowerCase() ;// 'banana' ... JS 真的很怪 ... 算術運算子我們之前提過算術運算子用來處理基本的數學運算，但如果遇到的不是數字型別的資料呢？ 請記得，只要算術運算子中介的任一方屬於數字型別，那麼另一方除了字串型別以外，都會被轉成數字型別加以運算。 123456789// + 對數字與布林進行運算100 + true ; // 101 100 + false ; // 100// + 對數字與 null 進行運算100 + null ; // 100// + 對數字與 undefined 進行運算100 + undefined ; // NaN// + 對數字與 NaN 進行運算100 + NaN ; // NaN 由上方程式碼可見，某些特殊純值型轉為數字後的值： true = 1 false = 0 null = 0 undefined = NaN 比較運算子我們在系列第 11 篇中有說明比較運算子屬於左相依性，因此我們判斷時應該從左邊向右邊看，以這個神奇的範例說明 JS 的判斷原理： 123456console.log(3 &lt; 2 &lt; 1) ; // true// 上面這段程式碼在 JS 引擎看起來是這樣：1. console.log((3 &lt; 2) &lt; 1) ; // 小於 &lt; 屬於左相依性，先看 3 &lt; 2 ，邏輯正確，回傳布林值 false。2. console.log( false &lt; 1) ; // 再看 false &lt; 1 ，比較布林值 false 與 1 ， false 會被強制型轉為 0。3. console.log( 0 &lt; 1) ; // 比較 0 與 1 ，邏輯正確，回傳布林值 true 。 嚴格等於JS 強制型轉的特色讓不同的資料型態放在一起時得以被轉型運算，就某種角度來看，是非常強大的功能。但，也因為強制型轉的特性可能會導致非預期的 BUG，所以，在實務上，我們會以 ===（嚴格等於）來判別兩資料在值與資料型別是否都相同，避免使用 ==（寬鬆等於）只比較兩資料的值，讓 JS 強制型轉其中一方資料而出現錯誤。 MDN：Equality comparisons and sameness 整理了兩數相等性的歸納表格，詳細內容可以點進去參考。 結論 強制型轉指的是，JS 處理不同資料型別之間的運算或判斷時，會強制轉換資料型別進行處理。 在字串運算子中，若兩參數有一方是字串型別，則另一方也會被轉成字串型別，進行字串串連。 在算數運算子中，若兩參數有一方是數字型別，則另一方（字串除外）也會被轉成數字型別，進行數字計算。 在判斷運算子處理時，必須綜合考慮運算子的優先性、相依性以及 JS 強制型轉的特性。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 3-24、3-26","link":"/2019/08/12/weird-JavaScript-13/"},{"title":"weirdJavaScript 17：偽裝命名空間","text":"當我們想要用相同的變數名稱來代指相似的資料，可以利用物件來建立偽裝的命名空間，避免資料被覆寫。 命名空間（Namespace） A container for variables and functionsTypically to keep variables and functions with the same name seperate. 命名空間指的是一個程式語言中儲存變數與函式名稱的容器，它的功用在於分離相同名稱的變數與函式。 然而， JavaScript 沒有 Namespace 這項功能。因此，當我們想要用同一個變數名稱來指涉相似的資料，後者所定義的值，往往會覆蓋掉前面所定義的值。 123var greet = 'Hello!' ;var greet = 'Hola!' ;console.log(greet) ; // Hola! 解決這樣的方法就是，借助物件的特性，假裝創造各自獨立的命名空間。 偽裝命名空間利用物件實字 {} 建立新物件，並將相同變數分別儲存進不同的物件中。 此時，即便我們擁有兩個相同的變數名稱，但因為分屬不同物件，兩者都會被存進電腦記憶體，各自獨立存在，不會被覆寫。 12345var greetEng = &#123;&#125; ;var greetSpn = &#123;&#125; ;greetEng.greet = 'Hello!' ;greetSpn.greet = 'Hola!' ;console.log(greetEng.greet,greetSpn.greet) ; // Hello! Hola! 注意！如果想在物件中建立一個新的物件，必須先宣告（初始化）物件，才能將變數或函數存進去，否則 JS 會因為找不到該物件，而將物件判定為 undefined ，以致取用運算子失效。 1234var greetEng = &#123;&#125; ;greetEng.greet = 'Hello!' ;// greetEng.say = &#123;&#125; ; 先宣告物件就可以執行greetEng.say.morning = 'Good morning!' ; // cannot set property of undefined 結論 命名空間指的是一個程式語言中儲存變數與函式名稱的容器，但 JavaScript 並沒有這項功能。 在 JS 中，當我們想要用同一個變數名稱來指涉相似的資料，可以利用物件來偽裝命名空間。 必須先宣告（初始化）物件後，才能開始在物件中新增屬性或方法。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-32","link":"/2019/08/14/weird-JavaScript-17/"},{"title":"weirdJavaScript 14：存在與布林、條件判斷與預設值","text":"小飛：「所以， JS 的動態型別與強制型轉到底有什麼用？」 有！這兩大特色幫助我們輕鬆判斷條件，設定預設值。 存在與布林既然在 JavaScript 中資料型別可以任意轉換，這也就表示任何資料都能被我們轉型成布林值：true 或 false。 在 JS 中，我們可以用 Boolean() 這個指令來檢驗資料轉型的布林值為何？ 1234Boolean('') ; // false ;Boolean(0) ; // false ;Boolean(null) ; // false ;Boolean(undefined) ; // false ; 從此可知，我們知道 空字串、0、null、undefined 在布林中都會被轉成 false，在 JS 中，我們可以說這些值不存在，或說什麼都不是（Nothing）。 而布林值的判別，能夠幫助我們檢驗資料的值是否存在，並用在條件判斷中進行流程管理。譬如 if 陳述句， if 條件的判斷取決於條件內容的布林值，若為 true ，就執行 {} 內的程式碼，若否，則執行 else{} 或結束判斷。 12345678var a = ' ' ; // 注意！空字串和空白字串是不一樣的！var b = 0 ;// === 優先性高於 &amp;&amp;，所以先判斷 b === 0 為 true，再判斷 a &amp;&amp; true。// 由於 a 為空白字串，轉成布林值為 true ，所以條件內容為 true &amp;&amp; true，執行 &#123;&#125; 程式碼。if(a &amp;&amp; b === 0)&#123; console.log('Something is there.') ; // Something is there.&#125; 設定預設值我們也可以利用邏輯運算子 ||（或） ，借助強制型轉與布林值的特性，來為變數賦予預設值。 邏輯運算子 ||（或） 的意義是，由左至右判斷中介雙方的資料的布林值，若左方變數的布林值為 true ，即回傳左方的資料，若左方布林值為 false ，則進一步判斷右方資料的布林值，若為 true ，即回傳右方資料。 以下方程式碼為例： 123456function welcome(name)&#123; name = name || 'my guest' ; console.log('Welcome to my blog, ' + name + '!') ;&#125;welcome('John') ; // Welcome to my blog, John! welcome() ; // Welcome to my blog, my guest! 結論 在 JS 中任何資料都能被轉型成布林值。 布林值的判別能夠幫助我們檢驗資料的值是否存在，並用在 if 條件判斷中進行流程管理。 我們也可以利用邏輯運算子 || ，借助強制型轉與布林值的特性，來為變數賦予預設值。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 3-27、3-28","link":"/2019/08/12/weird-JavaScript-14/"},{"title":"weirdJavaScript 15：創造物件、物件實字","text":"請用物件實字法創造物件。 物件實字（Object Literals）物件實字，就是用 {} 來創造一個新的物件，並直接在裡面定義我們所欲的 Name/Value Pairs。 12345678910var favoriteFood = &#123; name: 'Fei', delicacy: &#123; taiwanese: ['oyster omelet', 'egg roll'], westerm: ['spaghetti','fried chicken'], japan: ['sashimi', 'ramen'] &#125;, drink: ['bubble tea', 'latte'], moneyLeft: 877 &#125; 物件實字本身簡潔明瞭，是最常被用來創造物件的方法，其本身也可以被當作參數傳入函式： 1234567function callName(person)&#123; console.log('Hello! I\\'m ' + person.name + '. I am ' + person.age + ' years old.') ;&#125;callName(&#123; name: 'Fei', age: 23 &#125;) ; new Object()另一種方式是，用 new Object() 創造物件後，利用 . 或 [] 運算子一一新增所欲的屬性和方法，使用上不比實字表示法來得方便直覺。 12345678var John = new Object() ;John.age = 30 ;John.hobby = ['eat', 'sleep', 'working'] ;John['residence'] = new Object() ;John['residence']['city'] = 'Taipei' ;John['residence']['district'] = 'Daan' ;console.log(John) ; 結論 創造物件有兩種方式：利用物件實字 {} 或 new Object() 。 實務上多以物件實字法創造物件，但部分時候還是會用到 new 建構式來創造物件。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 3-31","link":"/2019/08/12/weird-JavaScript-15/"},{"title":"weirdJavaScript 19：一級函式","text":"函式就是物件，物件就是函式，就是所謂一級函式。 函式就是物件我們之前談到資料型別時，就已經提過：在 JavaScript 中，函式是一種特殊的物件。 也就是說，我們也可以賦予函式屬性以及方法： 12345678910function personSay()&#123; console.log('The function is an object in JavaScript!') ;&#125;personSay.who = 'John' ;personSay.age = 28 ;personSay.yell = function()&#123;console.log('JS is Soooooo HARD!!')&#125; ;console.log(personSay.who) ; // JohnpersonSay.yell() ; // JS is Soooooo HARD!! 而這樣的函式特色，在程式語言中被稱為一級函式（First Class Functions）。 一級函式（First Class Functions） Everything you can do with other types you can do with functions.Assign them to variables, pass them around, create them on the fly. 上面這段對於一級函式的簡介意思是：任何你對其它型別做的事情，你都可以用一級函式做到。 蛤？好拗口？這是什麼意思？ 意思就是，基本上，你可以利用一級函式做任何事情！包括將函式賦予給變數、將函式當作參數傳入另一個函式、利用實字語法建立函式、賦予函式屬性或方法等等。 現在聽起來很抽象，往後介紹閉包（Closure）時，就能夠深入理解一級函式的威力。 雖然一級函式並非 JavaScript 獨有的特色，但因為具備這樣的特性，使得 JavaScript 成為一種以函式為核心（Functional Programming）的程式設計語言。 函式物件在 JS 中，函式屬於一種特殊的物件，又稱為函式物件。 而物件本身是 Name/Value Pairs 的集合，因此函式物件可以擁有屬性或方法。 除了屬性或方法以外，函式物件還包括兩個我們不知道的特殊屬性：名稱屬性（Name）以及程式屬性（Code）。 函式物件的名稱屬性指的就是函式名稱。函式可以有名字，也可以沒有名字，沒有名字的函式又稱匿名函式（Anonymous Function）。 函式物件的程式屬性指的就是函式程式區塊，也就是 {} 內我們所寫的程式碼部分，而且，這個程式屬性是能夠被呼叫的（Invocable），也就是在函式名稱後方加上 ()。 1234567function yell()&#123; console.log('JS is Soooooo WEIRD!!')&#125;// yell 就是函式物件的名稱屬性// &#123;console.log('JS is Soooooo WEIRD!!')&#125; 就是函式物件的程式屬性// 利用 名稱屬性() 來呼叫執行程式屬性yell() ; 順便回顧一下，當我們呼叫函式後，會建立新的執行環境，以執行函式的程式區塊，也就是 {} 內的程式碼，而 {} 內的環境同時也是該函式中區域變數作用域的範圍。 課程以這張圖歸納了函式物件的組成： 結論 在 JavaScript 中，函式是一種特殊的物件，而這樣的特色被稱為一級函式。 在 JavaScript 中，函式屬於函式物件，可以擁有屬性與方法。 函式物件的組成包括：名稱屬性（可以是匿名的）、程式屬性（能夠被呼叫的）、屬性、方法。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-34","link":"/2019/08/14/weird-JavaScript-19/"},{"title":"weirdJavaScript 16：物件的屬性、方法以及取用","text":"學習取用物件的屬性和方法。 物件的屬性與方法在 JavaScript 中，物件與函式息息相關，因為函式是一種特殊的物件，兩者不應分開討論。 我們一再強調，物件就是 Name/Value 的集合，具有屬性和方法。 物件中的屬性指的是物件中的一組 Name/Value ，其 Value 屬於另一個基本型別（純值）或物件型別。 物件中的方法指的是物件中的一組 Name/Value ，其 Value 屬於另一個函式。 12345678910111213141516var person = &#123; // Property: 一組 Name/Value ，其中 Value 是'Fei'（純值） name: 'Fei', // Property: 一組 Name/Value ，其中 Value 是一個物件。 family: &#123; dad: 'Jason', mom: 'Teresa', bro: 'Bai' &#125;, // Property: 一組 Name/Value ，其中 Value 是一個陣列，因為陣列也屬於物件的一種。 friends: ['Shiba','giraffe','Fish'], // Method: 一組 Name/Value ，其中 Value 是一個函式，因為函式也屬於物件的一種。 say: function()&#123; console.log('Welcome to my blog!!') ; &#125;&#125; ; 值得注意的是， JS 引擎創造物件時，除了整個物件本身會被儲存在一個記憶體位置（Address），其中所有的屬性或方法也會分別被存進記憶體中。 當我們在存取、修改物件中的某一個屬性或方法時，其實 JS 引擎所指向的是儲存該屬性或方法的記憶體位置，而非整個物件儲存的記憶體位置。 只有當我們在取用整個物件時，JS 引擎才會指向儲存整個物件的記憶體位置。 物件、物件中的屬性與方法在記憶體中的儲存位置，對於傳值、傳參考的概念非常重要！ 總而言之，可以用課程中的這張圖來總結物件的結構： 屬性取用運算子我們可以利用屬性取用運算子 [] 來存取物件內的屬性，或呼叫物件內的方法。記得呼叫函式都要以 () 來呼叫。 注意， [] 內要用字串（String）來表示我們想取用的屬性或方法名稱（Name）： 1234console.log(person['name']) ; // Feiconsole.log(person['family']) ; // &#123; dad: 'Jason', mom: 'Teresa', bro: 'Bai'&#125;console.log(person['family']['bro']) ; // Baiperson['say']() ; // Welcome to my blog!! 除此之外，我們也可以用物件專屬的取用運算子 . 來存取物件內的屬性或呼叫物件內的方法。與 [] 不同的是，我們不需要用字串來表示所欲取用的 name，因此使用上更為簡潔。 1234console.log(person.name) ; // Feiconsole.log(person.friends) ; // ['Shiba','giraffe','Fish']console.log(person.friends[2]) ; // Fishperson.say() ; // Welcome to my blog!! 從 MDN 所整理的運算子優先性表格中，可以發現 . 運算子與 [] 運算子的優先次序是第二高的，僅次於群組運算子 () ，且為左相依性，由左至右運算。 當然，我們也可以利用 . 運算子與 [] 運算子新增、修改物件的屬性或方法： 123person.hobby = ['Coding, Singing, Traveling'] ;person['family'].sis = 'Mei' ;person.say = function()&#123;console.log('JS is so WEIRD!!')&#125; ; 結論 物件是 Name/Value 的集合 ，每一組鍵值配對都是一組屬性或方法。 JS 創造物件時，會把物件整個存進一個記憶體位置，也會將每一個屬性或方法分別儲存進不同的記憶體位置。 我們可以用 [] 或 . 運算子新增、修改、取用物件的屬性或呼叫物件的方法。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-30","link":"/2019/08/13/weird-JavaScript-16/"},{"title":"weirdJavaScript 21：傳值 v.s. 傳參考","text":"傳值 v.s. 傳參考， JavaScript 偷偷做但不告訴你的概念。 資料型別回顧 JavaScript 的資料型別，可以分為兩大類，共七種。哪兩類？哪七種呀？ 基本型別類（Primitive） String Number Boolean Null Undefined Symbol 物件型別類（Object） Object (Function / Array) 其中，基本型別的六種值會以純值的方式表現，而物件型別中的物件則是 Name/Value 的集合，換句話說，物件也是許多資料型別的集合。 除此之外，我們也說過，當宣告新的變數或值（物件）時，JS 都會將這些資料型別分別存進記憶體，而變數在讀取值時，其實是參照的是值在記憶體中的位置（Address）。 搞懂上面這兩個觀念之後，傳值與傳參考的原理就呼之欲出了！ 傳值（by Value）在 JavaScript 中，基本型別（純值）的變數賦值或拷貝大部分是以傳值的方式實現。 什麼意思？我們可以這樣解釋：因為基本型別本身就是純值，所以無論變數賦值，或是複製變數，大部分都是傳遞（純）值。 直接舉例說明： 12345var a = 100 ;var b = a ; // 複製變數console.log(a,b) ; // 100 100a = 200 ; // 變數更新（重新賦值）console.log(a,b) ; // 200 100 我們宣告變數 a 並賦值 100 ，接著宣告變數 b ，並讓它的值等於 a 。此時，JS 引擎在複製變數 a 的值時，會傳遞值 100 並賦予給變數 b ，使變數 b 值也等於 100。（如第 3 行結果） 如果我們接著修改變數 a ，賦值 200 ，此時變數 a 更新後的值等於 200，而變數 b 的值仍然是 100，並沒有改變。 也就是說，基本型別在賦予變數值、複製變數或更新（重新賦值）變數時，JS 引擎會參照到該值在記憶體中的位置，並傳遞值本身，為複製的變數建立一個新的記憶體位置來儲存傳遞的值。 所以，在上面這段範例中，第 2 行執行後，變數 a 和變數 b 雖然都是 100 ，但這兩個變數所參考的記憶體位置並不一樣，以致修改變數 a 後，變數 b 不受影響。 課程中以這張圖來說明傳值的概念： 傳參考（by Reference）在 JavaScript 中，物件型別（物件、函式、陣列）的變數賦值或拷貝大部分是以傳參考的方式實現。 同樣的思維，我們可以這樣解釋：因為物件型別本身就是物件（許多資料型別的集合），所以無論變數賦值，或是複製變數，大部分都是傳遞參考（物件）。 什麼是參考？也就是變數所參考到儲存物件的記憶體位置（Address）。因此，傳參考又稱為傳址。 請看下方範例： 12345678var a = &#123; name: 'Fei', age: 23&#125; ;var b = a ; // 複製變數console.log(a,b) ; // &#123;name: \"Fei\", age: 23&#125; &#123;name: \"Fei\", age: 23&#125;a.age = 17 ; // 變數更新（重新賦值）console.log(a,b) ; // &#123;name: \"Fei\", age: 17&#125; &#123;name: \"Fei\", age: 17&#125; 由於物件傳參考的特性，第 5 行執行後，變數 a 和變數 b 這兩個變數所參考的記憶體位置是相同的，都指向儲存物件 {name: &quot;Fei&quot;, age: 23} 的位置。 也就是說，物件型別在賦予變數值、複製變數或更新（重新賦值）變數時，JS 引擎會參照到該物件在記憶體中的位置，並傳遞參考位置，複製的變數會同樣參考到物件儲存的記憶體位置。 換句話說，物件並不像純值那樣會被複製到新的記憶體位置中。背後的真相是：物件不會被複製（新建記憶體位置儲存）。 是以，第 7 行執行後，修改變數 a 物件裡的 age 值，等同修改了變數 b 物件裡的 age 值，因為變數 a 和變數 b 這兩個變數所參考的記憶體位置是相同的，指的是同一個物件。 其實，我們也曾經說過，JavaScript 物件中的每個 Name/Value 都各自擁有不同的記憶體位置，既然如此，我們可以想成：儲存物件的記憶體位置，該物件在取用屬性或方法時，也會參考到儲存其所擁有的 Name/Value 的記憶體位置。 因此，我們必須將物件視為一個實體（Instance），當我們更新物件裡的屬性或方法時，修改（Mutate）的正是 Name/Value 記憶體位置的值，這當然會更動到所有參考到該物件實體的變數。 或許是考量效率問題，JS 在更新或複製變數時，若碰到物件資料，會以傳參考（指向相同記憶體位置）的方式實現。試想，如果要像純值那樣複製值本身，倘若物件擁有上百個 Name/Value Pairs 該怎麼辦？效率肯定會變差。那直接指向相同物件（的記憶體位置）不更省事？ 因為物件是 Name/Value 的集合，也是儲存 Name/Value 記憶體位置的集合。 最後，還有一個觀念：物件被傳入函式中執行，同樣擁有傳參考的特性。 1234567891011var a = &#123; name: 'Fei', age: 23&#125; ;var b = a ;function mutateProperty(obj)&#123; obj.age = 17 ; // 修改物件的屬性&#125;mutateProperty(a) ;console.log(a,b) ; // &#123;name: \"Fei\", age: 17&#125; &#123;name: \"Fei\", age: 17&#125; 課程以這張圖來說明傳參考的概念： 結論 在 JS 中，基本型別（純值）在賦予變數值、複製變數或更新（重新賦值）變數時，JS 引擎會參照到該值在記憶體中的位置，並傳遞值本身，為複製的變數建立一個新的記憶體位置來儲存傳遞的值。 在 JS 中，物件型別（物件、函式、陣列）在賦予變數值、複製變數或更新（重新賦值）變數時，JS 引擎會參照到該物件在記憶體中的位置，並傳遞參考位置，複製的變數會同樣參考到物件儲存的記憶體位置。此外，物件被傳入函式中執行也擁有傳參考的特性。 變數賦值、複製或更新（重新賦值），可以歸納到使用賦值運算子 = 的情境，此時純值會傳值，物件會傳參考。 賦值運算子 = 的意義在於，若賦值資料是第一次宣告，則 JS 會新建記憶體位置儲存該資料，並賦值給左方變數。 傳值或傳參考的歸納符合大部分的狀況，但有例外，且目前學界對於 JS 究竟是傳值、傳參考還是傳享（by Sharing）？並無定論，有興趣的人可以進一步參考下方資料文章。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-36 重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？ 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？","link":"/2019/08/15/weird-JavaScript-21/"},{"title":"weirdJavaScript 18：JSON v.s. 物件","text":"什麼？你說 JSON 就是物件？大錯特錯！ JSONJavaScript 物件表示法（JSON， JavaScript Object Notation），是一種輕量的資料交換語言，用來傳輸 Name/Value Pairs 所組成的資料物件。JSON 雖然屬於 JavaScript 中的子集，但是獨立於 JS 環境，可以被許多程式語言支援、解析，副檔名為 .json。 相較於 XML（Extensible Markup Language），由於 JSON 更加輕便、簡潔明瞭（在傳輸上不會浪費過多的頻寬，效率更高），當今開放資料多半以 JSON 格式開源，然而由於格式特性，兩者使用上還是有慣用的語言環境。JSON 常見於 JavaScript、Java、Node.js ，而 XML 常見於 PHP、C# 等網頁應用。 JSON 格式： 123456&#123; \"name\": \"John\", \"age\": 28, \"sex\": \"male\", \"isStudent\": false&#125; XML 格式： 1234567&lt;?xml version=\"1.0\"?&gt;&lt;object&gt; &lt;name&gt;John&lt;/name&gt; &lt;age&gt;28&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;isStudent&gt;false&lt;/isStudent&gt;&lt;/object&gt; JSON與Object的比較JSON 和 JS 物件的格式差異在於，JSON 中的 Name/Value 一定要用雙引號 &quot;&quot; 包覆，JS Object 則沒有規定。 JSON 格式： 123456&#123; \"name\": \"John\", \"age\": 28, \"sex\": \"male\", \"isStudent\": false&#125; JS 物件格式： 123456var obj = &#123; name: 'John', age: 28, sex: 'male', isStudent: false&#125; JSON轉ObjectJavaScript 內建 JSON.parse() 指令，能將 JSON 格式的字串（String）轉換成 JS 物件。 12var obj = JSON.parse('&#123;\"name\":\"John\",\"age\": 28,\"sex\": \"male\",\"isStudent\": false&#125;') ;console.log(obj) ; // Object: &#123;name: \"John\", age: 28, sex: \"male\", isStudent: false&#125; Object轉JSONJavaScript 內建 JSON.stringify() 指令，能將 JS 物件換成 JSON格式的字串（String）。 1234567var json = JSON.stringify(&#123; name: 'John', age: 28, sex: 'male', isStudent: false&#125;) ;console.log(json) ; // JSON String: &#123;\"name\":\"John\",\"age\":28,\"sex\":\"male\",\"isStudent\":false&#125; 結論 JSON 是一種發想於物件實字的輕量化資料交換格式，常見於開放資料。 和物件格式不同的是，JSON 中的 Name/Value 一定要用雙引號 &quot;&quot; 包覆。 JSON.parse() 能將 JSON 字串轉換成 JS 物件。 JSON.stringify() 能將 JS 物件轉換成 JSON 字串。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-33 維基百科：JSON 維基百科：XML","link":"/2019/08/14/weird-JavaScript-18/"},{"title":"weirdJavaScript 23：陣列","text":"講了那麼多的物件和函式，現在終於輪到不可或缺的邊緣人－陣列。 陣列（Array）陣列屬於物件型別的次型別，又稱陣列物件，它的內容可以是任何東西的集合。 也就是說，我在陣列裡面可以放任何的資料型別，包含字串、數字、布林、物件、函式物件、甚至另一個陣列。 123456789101112131415var arr = [ 'Bai', false, function(name)&#123; console.log('Hola! ' + name) ; &#125;, 5566, &#123; mom: 'Linda', city: 'Taipei', isCute: true &#125;, ['Eat','Sleep','Play Games']]console.log(arr) ; 我們知道物件是 Name/Value Pairs 的集合，其實陣列物件也是同樣的道理，只是它用索引值（Index）取代了 Name。 陣列的索引值由左至右從 0 開始，如果把上面的程式碼想像成陣列物件如下： 1234567891011121314var arr = [ 0: 'Bai', 1: false, 2: function(name)&#123; console.log('Hola! ' + name) ; &#125;, 3: 5566, 4: &#123; mom: 'Linda', city: 'Taipei', isCute: true &#125;, 5: ['Eat','Sleep','Play Games']] 我們可以透過取用運算子 [] 搭配索引值來取用物件內的資料。注意！物件的點運算子在陣列中是不能使用的。 12arr.2(arr.4.mom) ; // SyntaxError: Unexpected numberarr[2](arr[4].mom) ; // Hola! Linda 結論 陣列屬於特殊的陣列物件，它可以是任何資料型別的集合。 我們可以利用取用運算子 [] 搭配陣列索引值來取用陣列裡的資料。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-38","link":"/2019/08/17/weird-JavaScript-23/"},{"title":"weirdJavaScript 20：函式陳述式與函式表達式","text":"JavaScript 的兩種句型：陳述式和表達式。 表達式（Expression） A unit of code that results in a value.It doesn’t have to save to a variable. 表達式的執行結果會回傳一個值，而該值不一定要賦予給任一變數。譬如運算、賦值、呼叫函式等等。 1234a = 55 ; // 555 * 6 ; // 30'a' + 'b' ; // 'ab'false + 100 ; // 100 陳述式（Statement） A unit of code that would not result in a value. 陳述式的執行結果不會回傳值。譬如 var 宣告、函式宣告、 switch 判斷、 {} 函式區塊、 break 等等。 有些陳述式會需要表達式產生值後才能運作，譬如 if 。 12var a ;if(a === 3)&#123; ... &#125; // 其中 a === 3 屬於表達式，若回傳 true ，執行 &#123;&#125; 內程式碼 函式陳述式也就是函式宣告。我們在 04 篇說過，函式宣告在全域環境具有 Hoisting 的效果，能在宣告之前呼叫函式。 123456greet() ;function greet()&#123; console.log('Function declaration statement would be hoisted in JS.')&#125;// greet() 函式物件的名稱屬性： greet// greet() 函式物件的程式屬性： &#123; console.log('Function declaration statement would be hoisted in JS.') &#125; 函式表達式（Function Expression）既然函式屬於一種特殊的函式物件，當然能夠被賦予給任一變數，這樣的方式稱為函式表達式。 唯要特別注意的是，將函式物件於賦予任一變數後，我們就能用該變數名稱參照到該函式物件，因此在表達函式物件時，不需要另外定義函式物件的名稱屬性，也就是說，必須使用匿名函式（Anonymous Function）來表達函式物件。 然而，函式表達並非函式陳述，因此並沒有 Hoisting 的效果，必須等到變數被賦予函式物件後，才能用該變數呼叫函式。 12345anonymousGreet() ; // anonymousGreet is not a function ; anonymousGreet 會先被宣告為 undefined！var anonymousGreet = function()&#123; console.log('Function expression could be anonymous.')&#125;anonymousGreet() ; // 必須等到賦予函式物件後才能呼叫 一級函式與函式表達在 JS 中，由於一級函式的特色，我們可以將一個函式物件當作另一個函式的參數，丟進函式中執行。 結合函式表達的概念，我們能將一個儲存函式物件的變數當作參數丟進另一個函式中，並在函式中呼叫該函式： 12345678var greet = function(num1,num2)&#123; console.log(num1 + num2) ;&#125;call(greet) ;function call(a)&#123; a(55,66) ; // 121&#125; 當然，我們也可以立即創造一個函式，將它當作參數丟進另一個函式並執行： 1234567call(function(name)&#123; console.log('Hola! '+ name)&#125;) ;function call(a)&#123; a('John') ; // Hola! John&#125; 結論 表達式的執行結果會回傳一個值；陳述式的執行結果不會回傳值。 函式陳述式指的是函式宣告，在全域環境中具有 Hoisting 特性，能夠在宣告之前呼叫。 函式表達式指的是將一個函式（物件）賦予任一個變數。 結合一級函式的特色，參考到函式物件的變數可以被當作參數丟進另一個函式中執行並回船結果。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-35 MDN：Statements and declarations MDN：Function expression","link":"/2019/08/15/weird-JavaScript-20/"},{"title":"weirdJavaScript 22：What's this ?","text":"你指的 this 到底是哪個 this ？ 回顧函式的執行環境經過前面一連串的講解，我們知道，當一個函式被呼叫後，JS 引擎會為該函式創造屬於它的執行環境。而執行環境本身就是該函式中區域變數的變數環境，也就是作用域的範圍。我們還可以依據函式所處的詞彙環境，判斷函式執行時，如果找不到所需的變數，JS 會參考到的外部環境為何。 除此之外，當新的函式執行環境被創造時，JS 引擎也會幫我們建立一個新的變數 this 。 課程歸納如下： 在第 03 篇介紹全域環境時，我們說過，全域環境就是全域物件 window ，此時變數 this 指的就是全域物件。 1234var a = 5566 ;console.log(window) ;console.log(this) ;console.log(window.a === this.a) ; // true 但是，當函式被呼叫後，在該函式的執行環境中，變數 this 所代指的對象是會改變的。 So, what is “this” ? this In most cases, the value of this is determined by how a function is called. (MDN) this 是一個變數（代名詞），在一個函式被呼叫時，它會在新的執行環境中被建立，而 this 所指涉的對象取決於該函式如何被呼叫。 什麼樣的情況叫做如何被呼叫？ 有個簡單的法則是：在大部分的狀況下，我們可以透過函式被誰呼叫來判斷this 所代指的對象。 簡言之，this 會指向呼叫該函式的物件。 雖然這個法則適用於大部分狀況，但有例外。 純粹呼叫（Simple Call）我們用程式碼舉例說明，首先，以全域為例： 12345678function a()&#123; console.log(this) ; // window&#125;var b = function()&#123; console.log(this) ; // window &#125;a() ; b() ; 我們會發現，呼叫函式 a 與函式 b 後，在兩者的執行環境中，變數 this 都會指向全域物件 window 。 因為，在這個例子，函式 a 與函式 b 都是被全域物件呼叫的，所以 this 會代指全域物件 window ，這樣看或許比較清楚： 12window.a() ; window.b() ; 接著，我們把函式 b 放進函式 a ： 12345678910111213var name = 'Bai'function a()&#123; console.log(this.name) ; // Bai var name = 'Fei' var b = function()&#123; console.log(this.name) ; // Bai &#125; b() ;&#125;a() ; 此時我們會發現，儘管函式 b 在函式 a 中被呼叫，但函式 a 與函式 b 中的 this 都指向全域物件 window，因此會取用到 Bai。 為什麼？老實說，我也不清楚。只能說，JavaScript 的設計就是這樣（？） 我的解釋是：雖然函式 b 在函式 a 中，但呼叫函式 b 的依舊是全域物件 window ，仔細觀察， b() 並沒有被誰呼叫，因此 this 依然指向 window。 像這樣直接呼叫函式，被稱為純粹呼叫（Simple Call），此時變數 this 都會指向全域物件 window。 那什麼叫做被誰（物件）呼叫？ 呼叫物件方法（Call Object Method）呼叫物件方法（Call Object Method），就是函式被物件呼叫： 1234567891011var name = 'Bai' ;var person = &#123; name: 'Fei', say: say // 物件裡的 name/value 其中的 value 為函式，就屬於物件的方法。&#125;function say()&#123; console.log(this.name) ;&#125;say() ; // Bai person.say() ; // Fei 同理， say() 被全域物件呼叫（可以看成 window.say() ），所以 this.name 等同於 window.name ，讀到的值為 Bai。 而 person.say() ，呼叫函式 say 的物件就是它前面的物件 person ，也就是說，在函式 say 執行時，其執行環境內所創造的 this 會指向呼叫函式 say 的物件 person ，所以 this.name 等同於 person.name ，讀到的值就會是 Fei 。 你可能會覺得，咦？可是物件 person 的方法 say 是參考全域物件中的函式 say，但這和 this 無關，this 指涉的對象只取決於哪一個物件呼叫該函式。 純粹呼叫與呼叫物件方法最後，我們結合純粹呼叫和呼叫物件方法的例子： 123456789101112var person = &#123; name: 'Fei', greet: function()&#123; function reviseName(newName)&#123; this.name = newName ; &#125; reviseName('Foo') ; // 儘管處在函式 greet 裡，但仍屬於純粹呼叫，this 代指 window。 console.log(this.name) ; // Fei &#125; &#125;person.greet() ; console.log(name) ; // Foo ；全域物件會新增一個變數 name ，其值為 Foo 。 同樣的道理，許多人看到函式 reviseName 處在物件 person 中，就誤解函式 reviseName 裡面的 this 也會指向物件 person ，但並不是，因為 this 指涉的對象取決於函式如何被呼叫， this 在函式執行後才會出現作用，跟函式本身在哪裡被宣告沒有關係，這點要特別小心。 是以，在這個例子中，函式 reviseName 被純粹呼叫，其 this 代指的就會是全域物件 window ，會在全域中新增一個變數 name 其值為 Foo 。 如果要達到修改物件 person 中 name 的目的，我們可以利用執行環境中變數作用域以及範圍鍊的特性，在函式 greet 中宣告新的變數（通常會命名為 self 或 that ），並賦予 this 的值： person（在函式 greet 中 this 代指 person），讓子函式 reviseName 可以向外參考取用到該變數，以修改物件 person 中的 name 。 方法如下： 123456789101112var person = &#123; name: 'Fei', greet: function()&#123; var self = this ; function reviseName(newName)&#123; self.name = newName ; &#125; reviseName('Foo') ; console.log(self.name) ; // Foo &#125; &#125;person.greet() ; 弄懂 this 在純粹呼叫與物件方法呼叫上的指涉差異，我們就能判斷大部分情況 this 代指的對象了。 由於 this 的例外狀況還有很多，詳細請容我日後再介紹，有興趣的朋友可以先閱讀參考資料中的大神文章，對 this 的理解會更加深刻。 結論 this 是一個變數（代名詞），在一個函式被呼叫時，它會在新的函式執行環境中被建立。 在大部分的狀況下，this 會指向呼叫該函式的物件，但有例外狀況。 當函式被純粹呼叫時，this 都會指向全域物件 window 。 當函式被物件呼叫（呼叫物件方法）時，this 會指向呼叫該函式的物件。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-37 MDN：this 重新認識 JavaScript: Day 20 What’s “THIS” in JavaScript (鐵人精華版) 淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂 卡斯伯：鐵人賽：JavaScript 的 this 到底是誰？","link":"/2019/08/16/weird-JavaScript-22/"},{"title":"weird-JavaScript 25： 重載函式","text":"許多程式語言中都有重載函式的設定，但 JavaScript 卻沒有。為什麼？ 重載函式（Function Overloading）重載函式的意思是，讓相同的函式擁有不同數量的參數。 由於在 JavaScript 中，函式屬於特別的函式物件，並不支援重載函式的功能。 不過，也因為函式在 JavaScript 中具有一級函式的特色，我們可以利用預設值，或將功能包裝成另一個函式，在流程中呼叫。 123456789101112131415161718192021function greet(name, age, city)&#123; city = city || 'Taipei' ; if(city === 'Taipei') &#123; console.log('Hello! I am ' + name + ', and ' + age + 'years old. I came from Taiwan.') ; &#125; if(city === 'Tokyo') &#123; console.log('Hello! I am ' + name + ', and ' + age + 'years old. I came from Japan ') ; &#125;&#125;function greetTaipei(name, age)&#123; return greet(name, age, 'Taipei') ;&#125;function greetTokyo(name, age)&#123; return greet(name, age, 'Tokyo') ;&#125;greetTaipei('Fei', 23) ;greetTokyo('Bai', 28) ; 結論 在 JavaScript 中，函式屬於特別的函式物件，並不支援重載函式的功能。 在 JavaScript 中，由於一級函式的特性，我們可以利用預設值或包裝函式的方式，達到重載函式的目的。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-40","link":"/2019/08/20/weird-JavaScript-25/"},{"title":"weird-JavaScript 26： 語法解析器","text":"再強調一次，什麼是語法解析器？ 語法解析器（Syntax Parsers）我們在第 01 篇解釋道，語法解析器會幫助我們解析程式碼，並轉換成電腦看得懂的語言（指令），讓電腦執行。 也就是說，我們所寫的程式碼並非由電腦直接執行，會先經過語法解析器轉譯，如果沒有語法錯誤，再由電腦執行我們所寫的程式碼。 語法解析器是 JavaScript 引擎中的一部分，它會一個字一個字解析我們所寫的程式碼，譬如看到 r ，它會預期接著 e 、 t 、 u 、 r ‘ n， 也就是 return ，並解析為 回傳 指令，接著預期接下來會出現一串表達式，直到碰到分號 ; （Semicolon），表示該段落解析結束。如果中間拼字有誤，就會出現 SyntaxError 。 在執行程式碼之前，想像語法解析器會按照規則，逐字逐行地幫我們解讀程式碼，轉換成電腦能夠理解的語言，且如果需要的話，語法解析器會自己幫我們改變程式碼，以利引擎執行。 無論是哪一種程式語言，理解語法解析器的邏輯與規則，對開發者來說非常重要。 結論 語法解析器會幫助我們解析程式碼，並轉換成電腦看得懂的語言後，讓電腦執行程式碼。 在執行程式碼之前，想像語法解析器會按照規則，逐字逐行地幫我們解讀程式碼，並轉換成電腦能夠理解的語言，且如果需要的話，語法解析器會自己幫我們改變程式碼，以利引擎執行。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-41","link":"/2019/08/20/weird-JavaScript-26/"},{"title":"weird-JavaScript 27：自動插入分號","text":"JavaScript 的語法解析器會自動幫我們加上分號，這有時候可能會造成一些問題。 分號（Semicolon）先前提過， JavaScript 的語法解析器會幫助我們轉譯程式碼，在過程中也會自動幫我們處理一些事情，進而改變我們的程式碼。 其中一件事是，JS 引擎會自動幫我們插入分號（Automatic Semicolon Insertion）。 分號 ; 在 JavaScript 中沒有任何語意，它的功能是表示語法段落的結束。 有寫過 JavaScript 一段時間的人或許會發現，分號在程式碼中並不是必要的，這是因為 JS 引擎會自動幫我們在必要的地方加上分號。 譬如 return 後面要接的應該是一段表達式，但如果你沒有補上表達式，直接按下 Enter 鍵至下一行繼續撰寫程式碼，JS 會偵測到 return 後方的 carriage return（按下 Enter 鍵所產生的字元），以為你已經表達完 retrun 陳述，因此自動幫你補上分號，確保 return 陳述句有效，即什麼都不做（回傳空值），最後讓電腦執行。 舉例來說，你寫的程式碼是這樣： 12345678function getName()&#123; return &#123; name: 'Fei' &#125;&#125;getNam() ; 但 JS 語法解析後會變成這樣： 12345678function getName()&#123; return ; &#123; name: 'Fei' &#125;&#125;getNam() ; 在上例中，原本我們預期想要得到一個物件，執行結果卻是 undefined 。這是因為 return 後面接著按下 Enter 所產生的 carriage return ，所以 JS 語法解析會自動幫我們補上分號，確保語法正確。 我們可以把將物件的左括弧 { 接在 return 後方，確保 JS 解析語法時，瞭解我們的陳述尚未結束，會接續到下一行。 1234567function getName()&#123; return &#123; name: 'Fei' &#125;&#125;getNam() ; 此時就能如期回傳物件 {name: &#39;Fei&#39;} 。 結論 在 JavaScript 中，分號不是必要的，但仍建議在預期的地方加上分號，避免 JS 引擎解析語法時自動補上所導致的錯誤。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-42 Javascript 分號戰爭","link":"/2019/08/21/weird-JavaScript-27/"},{"title":"weirdJavaScript 24： 參數（parameter v.s. arguments）","text":"函式的參數（Parameter）和參數 arguments 有什麼關係？ 參數（Parameter）當我們在宣告函式時，會定義所需帶入的數值，也就是 () 裡面的變數，這個被丟進函數裡的數就是所謂的參數（Parameter）。 123456// a 和 b 就是函式的參數function calc(a, b)&#123; console.log(a * b) ;&#125;calc(55, 66) ; // 55 和 66 就是函式 calc 的參數 參數（Arguments）而在 JavaScript 中有一個關鍵字也叫作參數： arguments，它跟變數 this 一樣，在函式執行後被創造，指的是函式執行環境裡，那些被丟進來的參數們。 The parameters you pass to a functionJavaScript gives you a keyword of the same name which contains them all 簡單來說，arguments 就是函式參數的集合，它會以類陣列（Array-like）的形式存在於函式執行環境中，供我們取用。 12345function calc(a, b)&#123; console.log(arguments) ; // Arguments(2):[55, 66]&#125;calc(55, 66) ; 必須謹記！ arguments 是類陣列，而不是陣列。雖然它擁有部分陣列的特性，但大多數陣列可以使用的方法， argument 都不能使用。 不過，我們可以透過取用運算子 [] 來取用 arguments 裡的某一個參數。 12345function calc(a, b)&#123; console.log(arguments[1]) ; 66&#125;calc(55, 66) ; 在 JavaScript 中，我們可以設定函式所欲代入的參數，但真正執行時卻不一定要代入參數，這不會導致 JS 報錯。 當我們執行函式並代入參數時，必須由左至右逐一代入定義的參數，任意跳過都是不被 JS 接受的。 如果沒有參數被丟進函式，JS 引擎仍會執行函式，由於變數 Hoisting 的特性，沒有代入的參數會自動被定義成 undefined 。 12345678function calc(a, b, c)&#123; console.log(a) ; console.log(b) ; console.log(c) ; // undefined console.log(arguments) ; // Arguments(2):[55, 66]&#125;calc(55, ,66) ; // SyntaxError: Unexpected tokencalc(55, 66) ; 在 ES6 之後，我們可以在宣告函式時設定參數的預設值，或直接在函式區塊內透過邏輯運算子 || 設定預設值，避免 undefined 。 12345678function calc(a, b, c=100)&#123; b = b || 66 ; console.log(a) ; console.log(b) ; console.log(c) ; // 100 console.log(a * b * c) ; &#125;calc(55) ; 我們可以利用 arguments.length 的方法來判斷傳入參數的數量或參數是否為 undefined： 1234567function calc(a, b, c=100)&#123; if(arguments.length === 0)&#123; return ; // 結束函式(不做任何事) &#125; console.log(a * b * c) ; &#125;calc() ; 在 ES6 以後，我們可以透過展開運算子（Spread Operator） ... 將陣列中的值逐一展開後丟進函式中處理： 12345const nums = [1, 2, 3] ;function calc(a, b, c)&#123; console.log(a * b * c) ; // 6&#125;calc(...nums) ; 結論 函式被呼叫後，JS 引擎會自動幫我們宣告一個變數 arguments 。 arguments 是函式參數的集合，會以類陣列的形式存在於函式執行環境中供我們取用。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 3-39","link":"/2019/08/17/weird-JavaScript-24/"},{"title":"weird-JavaScript 28：空格","text":"在 JavaScript 中，怎麼使用空格，是門藝術。 空格（Whitespace） Invisible characters that create literal ‘space’ in your written code.Carriage return, Tab and Space. 空格在程式碼中表示創造空間的隱形字元，譬如 Enter 鍵、 Tab 鍵以及空白鍵。 JavaScript 語法解析器對空格的規範相當自由，且空格字元在程式中並不會被執行，善用空格可以幫助我們寫出可讀性高的程式碼。 雖然下面這段程式碼也是可以執行的，但我們通常不會用這種風格： 1234567var a=55 +'66';console.log(a) ; 搭配註解 // 的使用，我們可以在程式碼中紀錄開發歷程。 123456789101112131415var // first name of the person firstname, // last name of the person lastname, // the language(can be 'en' or 'ch') language ;var person = &#123; firstname: 'Fei', lastname: 'Chen', language: 'ch'&#125; 結論 空格在程式碼中表示創造空間的隱形字元，譬如 Enter 鍵、 Tab 鍵以及空白鍵。 空格字元在程式中並不會被執行，善用空格可以幫助我們寫出可讀性高的程式碼。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-43","link":"/2019/08/21/weird-JavaScript-28/"},{"title":"weird-JavaScript 29：立即呼叫函式表達式（IIFEs）","text":"有一種函式，我們用完就丟。 創造函式的方法至今，我們已經介紹過創造函式的兩種方法，還記得嗎？ 函式陳述式（Function Statement） 函式表達式（Function Expression） 函式陳述指的是宣告一個有名字的函式，具有 Hoisting 的特性，JS 會將宣告的函式逐一存進記憶體，等到我們呼叫時才執行。 下方是一個函式陳述，即函式宣告： 123456greet('Bai') ;function greet(name)&#123; console.log('HI! ' + name) ;&#125;greet('John') ; 函式表達指的是，我們先創造一個沒有名字的函式（匿名函式），並將它賦予給一個變數，我們可以透過該變數名稱呼叫函式。 注意！函式表達並沒有 Hoisting 的特性，因此無法在表達前執行。 下方是一個函式表達式： 123456// greet('Bai') ; // greet is not a funciton// console.log(greet) ; // undefined var greet = function(name)&#123; console.log('HI! ' + name) ;&#125;greet('John') ; 我們說過，表達式都會產生一個值，而函式表達之所以屬於表達式，是因為它會創造一個函式，並儲存至記憶體，接著賦值給另一個變數。 所以，當我們 console.log() 該變數，會得到我們所創造的函式。 1234var greet = function(name)&#123; console.log('HI! ' + name) ;&#125;console.log(greet) ; 還記得函式屬於什麼嗎？ 立即呼叫函式表達式（Immediately Invoked Function Expressions）函式屬於特殊的物件，也就是函式物件，具有名稱屬性與程式屬性，也可以儲存其他屬性或方法。 在函式表達中，我們創造一個匿名函式，雖然它沒有名字，但已經有程式屬性，當然可以立刻呼叫它。 怎麼呼叫？一樣，在函式物件後面加上 () 。 由於我們要賦值給變數 greet ，所以，這裡我們可以利用 return 把函式表達改寫成： 1234567var greet = function(name)&#123; return 'HI! ' + name ;&#125;('John')// 此時，變數會等於回傳的值，並非函式本身，自然不能呼叫。// greet() ; // greet is not a functionconsole.log(greet) ; 發現了嗎？我們在創造函式物件的同時，可以立即呼叫它，執行後回傳結果。 既然可以立即呼叫，執行運算，如果這函式我只打算用一次，何必還要賦值給另一個變數，佔記憶體空間？ 所以，我們是不是可以這樣寫？ 123function(name)&#123; console.log('HI! ' + name) ;&#125;('John') 但是 JS 引擎卻告訴你： JavaScript 笑你，嘻嘻。 這因為 JS 語法解析器看到一段程式碼，如果是由 function 開頭，它會預期這是一段函式陳述句，必須給函式補上名字。 但函式陳述不能立即呼叫，我們必須想辦法讓程式碼第一個字不為 function 。 最簡便的做法，就是利用群組運算子 ()，將匿名函式整個包起來，變成一個表達式，這樣就不會是 function 起頭了。 123(function(name)&#123; console.log('HI! ' + name) ;&#125;)('John') ; 如果你想這樣寫也是可以的： 123(function(name)&#123; console.log('HI! ' + name) ;&#125;('John')) ; 選一種風格，就別再變了吧！ 這樣的函式，就是所謂的立即呼叫函式表達式（IIFEs），利用表達式創造一個函式物件後，立刻呼叫，執行運算，用完就丟。 蛤？你問為什麼用 () 包起來就可以？因為只要在群組運算子 () 裡面放任何純值或物件，都會變成表達（創造一個值）。不信你試試： 1234'I am so hungry.' // 'I am so hungry.'( 55 + 66 ) ; // 121(function()&#123;console.log('JS is so HARD!!')&#125;) ; // function// (function try()&#123;console.log('JS is so HARD!!')&#125;) ; // unexpected token try （有名字的函式不行） 結論 立即呼叫函式表達式（IIFEs）：利用表達式創造一個函式物件後，立刻呼叫，執行運算，用完就丟。 IIFEs 常見於各種框架與資源庫中，當我們不需要重複執行函式時，可以利用 IIFEs 減少記憶體負擔。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-44","link":"/2019/08/23/weird-JavaScript-29/"},{"title":"weird-JavaScript 30：IIFEs 與安全程式碼","text":"什麼情況下會用到 IIFEs ？ IIFEs與非同步回呼立即執行函式表達式（IIFEs），指的是我們利用表達式創造函式後，立即呼叫，執行運算，用完就丟。 函式立即呼叫後，JS 會建立屬於它的執行環境，加入執行堆疊，並接著執行程式碼。 函式運算後回傳值（如果有 return 的話），消滅執行環境，離開執行堆疊，該 IIFEs 的生命也就結束了，因為只用一次。 IIFEs 用完就丟的特性，讓我們能夠立即執行非同步回呼，避免 JS 引擎將它們放進事件佇列，等到最後才逐一執行。 先前我們舉過 setTimeout 的例子： 12345for(var i = 1 ; i &lt;= 10 ; i ++)&#123; setTimeout(function()&#123; console.log('這是第 ' + i + ` 次執行。`) ; &#125;,1000)&#125; 在這樣的狀況下，JS 引擎會等到執行堆疊為空時，才執行 setTimeout 的回呼函式，此時 i = 11 ，執行結果將會是： (10) 這是第 11 次執行。 我們可以利用 IIFEs 將 setTimeout 包起來，並傳入 i ，每跑一次迴圈，就立即執行回呼函式，達到我們預期的效果： 1234567for(var i = 1 ; i &lt;= 10 ; i ++)&#123; (function(i)&#123; setTimeout(function()&#123; console.log('這是第 ' + i + ` 次執行。`) ; &#125;,1000 * i) &#125;)(i) ;&#125; 這是第 1 次執行。這是第 2 次執行。…這是第 10 次執行。 安全程式碼（Safe Code）IIFEs 能夠立即呼叫函式，創造新的執行環境，執行完後隨即消滅。 這樣的特性可以幫助我們避免污染全域，讓只具備功能性的變數隨著執行環境生滅，而這樣的作法就是所謂安全程式碼。 1234567(function(name)&#123; var greeting = 'Hello'; console.log(greeting + ' ' + name + '.') ;&#125;)('John') ;console.log(greeting) ; // is not defined 換句話說，我們可以將所欲處理的事情包進 IIFEs 中執行，只 return 需要的值，其他沒用的值就不要回傳。 12345(function(name)&#123; var greeting = 'Hello'; // greeting 只是具備功能性的變數，隨著函式執行環境生滅。 return greeting + ' ' + name + '.' ;&#125;)('John') ; 如果我們想要取用全域物件，可以利用物件傳參考的特性，將 window 傳入 IIFEs 中，或者直接取用、修改： 1234567891011var greeting = 'Hello' ;(function(global, name)&#123; global.greeting = 'Hola' ; // greeting = 'Hola' ; 直接取用，修改全域變數。 // var greeting = 'Bonjour' ; 宣告為區域變數，並直接取用。 console.log(greeting + ' ' + name + '.') ;&#125;)(window, 'John') ;console.log(greeting) ; // Hola 結論 IIFEs 能夠立即呼叫函式，創造新的執行環境，執行完後隨即消滅，這樣的特性可以幫助我們避免污染全域，讓只具備功能性的變數隨著執行環境生滅，而這樣的作法就是所謂的安全程式碼。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-45","link":"/2019/08/24/weird-JavaScript-30/"},{"title":"weird-JavaScript 31：閉包（1）","text":"學了這麼多，現在我們來嘗試理解 JS 小魔王：閉包。 一級函式JavaScript 擁有一級函式的特性，函式（Function）屬於特殊的函式物件，可以被視為一種資料型態。 所以，我們透過函式 return 另一個函式，並連續呼叫、執行，就像這樣： 12345678function greet(whattosay)&#123; return function(name)&#123; console.log(whattosay + ' ' + name) ; &#125;&#125;greet('Hello!')('John') ; 把函式想像成模板，我們可以傳入所欲的參數，並將它賦值給一個變數，再利用該變數呼叫函式。 123456789101112function greet(whattosay)&#123; return function(name)&#123; console.log(whattosay + ' ' + name) ; &#125;&#125;var sayHola = greet('Hola!') ;var sayHello = greet('Hello!') ;sayHola('John') ;sayHello('John') ; 當 JS 讀到 var sayHola = greet(&#39;Hola!&#39;) ; 時，它會創造函式 greet(whattosay) 的執行環境，將 &#39;Hola!&#39; 作為參數傳入，並回傳匿名函式 function(name) 賦值給變數 sayHola ，最後消滅函式 greet(whattosay) 的執行環境。 咦？等等，有沒有覺得怪怪的？ 既然函式 greet(whattosay) 的執行環境已經消滅，為什麼 JS 讀到 sayHola(&#39;John&#39;) 的時候，JS 還記得 function(name) 裡的 whattosay 指的是 &#39;Hola!&#39; ？ 同理，為什麼 JS 讀到 sayHello(&#39;John&#39;) ; 的時候，JS 還記得 function(name) 裡的 whattosay 指的是 &#39;Hello!&#39; ？ 之前我們不是說，函式裡的區域變數（Local Variable），會隨著函式執行環境生滅嗎？ 函式的執行環境我們不斷強調，當一個函式被呼叫後，JS 會創造屬於該函式的執行環境，並分配一小部分的記憶體空間給該函式使用。 換句話說，每個函式的執行環境都有屬於自己的記憶體空間。我們所傳入的參數，或是在函式裡創造的變數（純值或物件）都會被儲存在該函式專屬的記憶體空間裡面，和其他函式無關，也和全域環境無關。 當函式執行完畢，執行環境被消滅後，基本上， JavaScript 引擎會清除該函式專屬的記憶體空間，這個動作被稱為垃圾回收（Garbage Collection）。 然而，儲存該函式參數和區域變數的記憶體空間並仍會存在，並不會被清除，這是 JS 引擎本身設計的特色，為了範圍鍊中變數的參考與取用。 在上面的例子中， JS 引擎在 function(name) 裡面找不到 whattosay ，所以它透過範圍鍊向外部（詞彙）環境 greet(whattosay) 尋找可用的變數。在 greet(whattosay) 中，儘管函式 greet(whattosay) 的執行環境已經消滅，可是， JS 引擎仍會保留儲存該函式參數和區域變數的記憶體空間，所以，JS 會取用到 whattosay ，等於傳入的參數 &#39;Hola!&#39;。 由此可見，sayHola(&#39;John&#39;) ; 的執行結果為 Hola! John 。 閉包（Closure）閉包，指的是利用函式執行環境，創造一個封閉空間，包住可供取用的變數。 閉包是我們巧用 JS 引擎會保留儲存函式參數與區域變數的記憶體空間的特性所產生的方法，可以幫助我們提升函式彈性、避免污染全域變數。 如同上述的例子，我們利用函式 greet(whattosay) 創造執行環境，傳入參數 whattosay 的值（&#39;Hola!&#39; 或 &#39;Hello!&#39;），並回傳另一個函式，供我們調用內部儲存的參數或區域變數。 在課程中利用這張圖來解釋閉包的範例： 結論 當一個函式被呼叫後，JS 會創造屬於該函式的執行環境，並分配一小部分的記憶體空間給該函式使用。 當函式執行完畢，執行環境被消滅後，儲存該函式參數和區域變數的記憶體空間並仍會存在，並不會被清除。 閉包，指的是利用函式執行環境，創造一個封閉空間，包住可供取用的變數。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-47","link":"/2019/08/25/weird-JavaScript-31/"},{"title":"weird-JavaScript 33：函式工廠","text":"透過閉包的原理，搭建一座座函式工廠吧！ 函式工廠（Function Factory）現在，我們已經瞭解閉包的概念，那麼，在什麼樣的情況下，我們會使用閉包？ 再重新檢視閉包的原理：利用函式執行環境，創造一個專屬的封閉空間（記憶體空間），包住可供取用的變數。 我們可以試著從閉包原理的特色去推想使用情境： 避免污染全域變數 製作客製化的函式 函式工廠，指的就是利用閉包，來協助我們製作函式化的函式，提升程式碼的編撰彈性。 什麼意思？以下面這段程式碼為例： 12345678910111213141516171819var greetEnglish = makeGreeting('en') ;var greetSpanish = makeGreeting('es') ;function makeGreeting(language)&#123; return function(firstname, lastname)&#123; if(language === 'en')&#123; console.log('Hello! ' + firstname + ' ' + lastname) ; &#125; if(language === 'es')&#123; console.log('Hola! ' + firstname + ' ' + lastname) ; &#125; &#125;&#125;greetEnglish('Fie', 'Lu') ;greetSpanish('Fei', 'Lu') ; 看懂了嗎？我們可以利用函式 makeGreeting(language) 來客製化不同語系回應的函式，只要傳入我們想要得到的語系參數 language 即可，有別於過去，我們還要針對不同語系一個一個宣告相對應的函式，大幅減少我們撰寫重複程式碼的時間。 在這裡，函式 makeGreeting(language) 就像一座工廠，利用其函式執行環境，創造一個專屬的封閉空間（記憶體空間），包住可供取用的變數（也就是參數 language ），並依據條件回傳不同的函式，而有不同的執行結果。 而之所以可以這樣做，這是因為 makeGreeting(&#39;en&#39;) 與 makeGreeting(&#39;es&#39;) 執行後，各自創造了自己的函式執行環境，也各自擁有屬於自己的記憶體空間，以儲存參數 language 的值 en 和 es ，讓 return 的 function(firstname, lastname) 能夠依照範圍鍊向外部詞彙環境參考 language 的值，根據 if 判斷條件的差異，印出不同語系的招呼語：&#39;Hello!&#39; 或是 &#39;Hola!&#39;。 在課程中，講師用這張圖來說明此例函式工廠的閉包原理： 結論 閉包的原理：利用函式執行環境，創造一個專屬的封閉空間（記憶體空間），包住可供取用的變數。 函式工廠指的就是利用閉包原理，把一個函式看成一個工廠，依據計算或變數判斷創造另一個函式，回傳供我們取用。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-48","link":"/2019/08/27/weird-JavaScript-33/"},{"title":"weird-JavaScript 34：閉包與回呼","text":"如果你曾經使用過 jQuery 、 setTimeout 等 Callback Function，其實你已經使用過閉包的概念了。 閉包與回呼以 setTimeout 這段程式碼作為範例： 12345678910function sayHiLater()&#123; var greeting = 'Hi!' ; setTimeout(function()&#123; console.log(greeting) ; &#125;, 3000) &#125;sayHiLater() ; 這段程式碼的執行結果為 「3 秒鐘後印出字串 Hi!」。 你有想過為什麼 3 秒後，回呼函式 function(){console.log(greeting) ;} ，為什麼能夠取用到外部詞彙環境的 greeting 嗎？明明函式 sayHiLater() 執行環境早就已經消滅。 這是因為閉包的機制會將 greeting 的值 &#39;Hi!&#39; 儲存在函式 sayHiLater 專屬的記憶體中，即便執行環境消滅、執行堆疊消失後，回呼函式在詞彙環境中仍然能夠取用到自由變數 greeting 的值 &#39;Hi!&#39; 。 我們在很遙遠的 05 篇中稍微提過回呼（Callback）這個概念，當時和非同步的概念綁在一起講。而這裡回呼函式 function(){console.log(greeting) ;} 同樣是非同步回呼函式，指的是非同步事件中，當執行堆疊為空以後，檢視事件佇列，回頭執行的函式。 而 function(){console.log(greeting) ;} 之所以匿名，是因為用了一級函式的概念，直接創造函式並丟入 setTimeout 中。 所以，仔細檢視這段程式碼的執行流程，應是這樣子的： JS 引擎建立全域執行環境、 window 和 this 。 Creation &amp; Hoisting : funciton sayHiLater 。 sayHiLater()，建立函式 sayHiLater 的函式執行環境，並執行程式內容。 var greeting = &#39;Hi!&#39; ，宣告區域變數 greeting ，賦值為 &#39;Hi!&#39; 。 setTimeout(function(){console.log(greeting)}, 3000)，創造匿名（非同步回呼）函式 function(){console.log(greeting) ，並將 setTimeout 放進事件佇列，等到執行堆疊為空時再執行。 函式 sayHiLater 的程式內容結束，消滅其函式執行環境（但其記憶體空間不會被消滅）。 全域執行環境結束，執行堆疊為空，檢視事件佇列裡的非同步事件。 執行 setTimeout ，倒數 3 秒（3000 豪秒），計時開始。 3 秒後，倒數完畢，執行回呼函式 function(){console.log(greeting) ，印出字串 Hi!。 回呼函式（Callback Function） A function you five to another function, to be run when the other function is finished.the function you call(invoke), ‘calls back’ by calling the function you gave it when finished. 理解回呼函式，可以舉 A 函式與 B 函式來說明：我們在 A 函式中創造 B 函式，接著執行 A 函式，等到 A 函式執行結束後，才回頭呼叫 B 函式，此時 B 函式就是所謂的回呼函式。 簡言之，回頭呼叫的函式，即回呼函式（其所在的外部執行環境可能已經消滅）。 回呼函式也可以想成：將 B 函式當作 A 函式的參數傳入，並在 A 函式中呼叫 B 函式。 從非同步事件或 DOM 監聽事件的角度來看，回呼函式也是指那些滿足特定條件才會被動觸發的函式，如上例 setTimeout 或 Click 事件。 課程中，講師用下面這個例子來解釋回呼函式： 1234567891011function tellMeWhenDone(callback)&#123; console.log('Function tellMeWhenDone is done!') ; callback() ; // 執行回呼函式&#125;// 創造一個匿名函式作為參數傳入函式 tellMeWhenDonetellMeWhenDone(function()&#123; console.log('Callback function is done!') ;&#125;) 稍加改寫講師舉的例子，想一想，下面的回呼函式會印出哪一個名字？ 123456789101112var name = 'Fei' ;function tellMeWhenDone(callback)&#123; var name = 'Bai' ; console.log('Function tellMeWhenDone is done!') ; callback() ; &#125;tellMeWhenDone(function()&#123; console.log(name) ;&#125;) 結論 回呼函式，即回頭呼叫執行的函式（其所在的外部執行環境可能已經消滅）。 回呼函式，也可以想成：將 B 函式當作 A 函式的參數傳入，並在 A 函式中呼叫 B 函式，則 B 函式為回呼函式。 回呼函式亦指那些滿足特定條件才會被動觸發的函式。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-49 重新認識 JavaScript: Day 18 Callback Function 與 IIFE","link":"/2019/08/29/weird-JavaScript-34/"},{"title":"weird-JavaScript 35：call()、apply()、bind()","text":"call() 、 apply() 、 bind() 都屬於函式的方法，可以用來改變函式中 this 代指的對象。 call()call() 用來呼叫函式，和我們平常使用 () 來呼叫函式是一樣的。 123456var logPerson = function() &#123; console.log(this) ; console.log('Call function log.') ;&#125; ;logPerson.call() ; 當然， call() 不可能這麼無聊，它具有綁定 this 的功能。我們可以在 () 傳入一個參數，指定函式執行時 this 代表的對象。 12345678910111213141516var person = &#123; firstname: 'John', lastname: 'Doe', age: 28, personSay: function()&#123; console.log('Hello! I am ' + this.firstname + ' ' + this.lastname) ; &#125;&#125; ;var logPerson = function() &#123; console.log(this) ; this.personSay() ; console.log(this.age) ;&#125; ;logPerson.call(person) ; 如果函式本身可以代入參數，可以在指定 this 的參數後方，也就是由第二個參數開始依序傳入。 1234567891011var person = &#123; firstname: 'John', lastname: 'Doe'&#125; ;var logPerson = function(para1, para2) &#123; console.log(this) ; console.log(this.firstname + ' ' + this.lastname + ' likes ' + para1 + ' and ' + para2) ;&#125; ;logPerson.call(person, 'writing', 'coding') ; 總結 call() 方法： Function.call(thisPara, para1, para2, ...) Function：所欲呼叫的函式 thisPara ：指定 this 的參數（通常是一個物件） para1 、 para2 執行函式的參數 apply()apply() 和 call() 的功能幾乎相同，能夠呼叫函式，傳入第一個參數指定 this 代指的對象，唯一的差別在於第二個參數只能傳入陣列。 1234567891011var person = &#123; firstname: 'John', lastname: 'Doe'&#125; ;var logPerson = function(para1, para2) &#123; console.log(this) ; console.log(this.firstname + ' ' + this.lastname + ' likes ' + para1 + ' and ' + para2) ;&#125;logPerson.apply(person, ['writing', 'coding']) ; call() 和 apply() 的功用都是呼叫函式，可以搭配 IIFEs 一起服用： 1234567891011121314var person = &#123; firstname: 'John', lastname: 'Doe'&#125; ;(function(para1, para2) &#123; console.log(this) ; console.log(this.firstname + ' ' + this.lastname + ' likes ' + para1 + ' and ' + para2) ;&#125;).call(person, 'writing', 'coding') ;(function(para1, para2) &#123; console.log(this) ; console.log(this.firstname + ' ' + this.lastname + ' likes ' + para1 + ' and ' + para2) ;&#125;).apply(person, ['writing', 'coding']) ; 總結 apply() 方法： Function.apply(thisPara, [arrayPara]) Function ：所欲呼叫的函式 thisPara ：指定 this 的參數（通常是一個物件） arrayPara：執行函式的參數（必須為一個陣列） bind()bind() 不會執行函式，而是複製（拷貝）函式，傳入第一個參數綁定 this 代指的對象，通常會賦值給另一個變數。 1234567891011121314151617181920var John = &#123; firstname: 'John', lastname: 'Doe'&#125; ;var Hai = &#123; firstname: 'Hai', lastname: 'An'&#125; ;var logPerson = function(para1, para2) &#123; console.log(this) ; console.log('Hello! I am ' + this.firstname + ' ' + this.lastname) ;&#125;var logJohn = logPerson.bind(John) ;var logFei = logPerson.bind(Fei) ;logJohn() ;logFei() ; bind() 第二個以後傳入的參數會逐一綁定相應的函式參數。 1234567891011121314function multiply(a, b) &#123; return a * b ;&#125;var multipleBySeven = multiply.bind(this, 7) ; // a = 7// a 綁定為 9 ，往後傳入參數由 b 開始代入。multipleBySeven(9) ; // b = 9multipleBySeven(12) ; // b = 12 var return30 = multiply.bind(this, 5, 6) ;// a = 5 ; b = 6return30() ; 總結 bind() 方法： Function.bind(thisPara, para1, para2, ...) Function ：所欲拷貝的函式 thisPara ：指定 this 的參數（通常是一個物件） arrayPara：拷貝函式的參數（綁定後無法更改） 結論 call() 、 apply() 、 bind() 請看各小節總結。 若不想指定 this 變數，可以傳入 this 變數本身，如 bind() 中 multiply(a, b) 一例。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-50 MDN：Function.prototype.call MDN：Function.prototype.apply MDN：Function.prototype.bind","link":"/2019/08/31/weird-JavaScript-35/"},{"title":"weird-JavaScript 36：函式程式設計（一）","text":"邁向進階 JavaScript ：函式程式設計（Functional Programming） 函式程式設計（Functional Programming）我們知道，一級函式是 JavaScript 的重點特色，讓我們能夠將函式當作參數傳入另一個函式，而這樣的特色，讓 JavaScript 得以函式為核心，去設計各式各樣的程式語法，達到不同的效果與目的，而這個思考與實作的過程就是所謂的函式程式設計（Functional Programming）。 在課程中，講師以範例來說明： 12345678var arr1 = [1, 2, 3] ;var arr2 = [] ;for (var i = 0 ; i &lt; arr1.length ; i++)&#123; arr2.push(arr1[i] * 2);&#125;console.log(arr2) ; 上面這個範例中，我們想將陣列 arr1 中的每一個數值乘以 2 以後傳入 arr2 中。 身為工程師，我們可以思考如何優化這段程式碼？如何讓程式碼更為簡潔？更為彈性？ 其實，我們可以善用函式讓程式碼更為彈性，只要改動函式的參數或程式屬性，就可以減少許多重複的工作，這就是函式程式設計的基本思維。 我們試著改寫上面這段程式碼，如下： 1234567891011121314151617var arr1 = [1, 2, 3] ;function mapForEach(array, func) &#123; var newArr = [] ; for (var i = 0 ; i &lt; array.length ; i++)&#123; newArr.push(func(array[i])); &#125; return newArr ;&#125;var arr2 = mapForEach(arr1, function(item)&#123; return item * 2 ;&#125;)console.log(arr2); 我們可以宣告一個函式 mapForEach ，並規定傳入兩個參數，第一個 array 是我們想要處理的陣列，第二個 func 是我們想要針對陣列中每一個值進行的運算方式。 現在，我們只要將 arr1 與 function(item){return item * 2 ;} 分別當作參數 array 與 func 傳入函式 mapForEach 中，執行回傳的結果再賦值給 arr2 ，這樣的方式與改寫前的範例程式碼，執行的結果是相同的。 不同的地方在哪？ 不同的地方在於，我們把原本程式碼的執行任務：「將陣列 arr1 中的每一個數值乘以 2 以後傳入 arr2 中」這一整件事情包裝成函式 mapForEach ，它的功能變成：「將陣列 array 中的每一個數值經過 func 運算以後 return」。 如此一來，我們可以自定義傳入的參數 array 和 func ，讓函式 mapForEach 的彈性與複用性變高了！ 譬如，我想要判斷陣列中的數值是否大於 1 ，我只要改變傳入 func 的參數： 1234567891011121314151617var arr1 = [1, 2, 3] ;function mapForEach(array, func) &#123; var newArr = [] ; for (var i = 0 ; i &lt; array.length ; i++)&#123; newArr.push(func(array[i])); &#125; return newArr ;&#125;var arr2 = mapForEach(arr1, function(item)&#123; return item &gt; 1 ;&#125;)console.log(arr2); 當然，我們也可以把函式存進一個變數後，將該變數當作參數傳入另一個函式，甚至先做一點處理。 課程中，講師利用 bind() 方法，改寫上面這段程式碼： 12345678910111213141516171819var arr1 = [1, 2, 3] ;function mapForEach(array, func) &#123; var newArr = [] ; for (var i = 0 ; i &lt; array.length ; i++)&#123; newArr.push(func(array[i])); &#125; return newArr ;&#125;var checkPastLimit = function(limiter, item)&#123; return itme &gt; limiter ;&#125;var arr2 = mapForEach(arr1, checkPastLimit.bind(this, 2))console.log(arr2); 透過 bind() ，我們可以自由綁定參數 limiter 的值。 如果不使用 bind() 呢？有沒有辦法改寫 checkPastLimit.bind(this, 2) ，設計一個函式，只要傳入 limiter 的值，還能達到同樣的結果？ 先別急著往下看，請試著動手寫寫看！ . . . . . . 123456789101112131415161718192021222324252627282930var arr1 = [1, 2, 3] ;function mapForEach(array, func) &#123; var newArr = [] ; for (var i = 0 ; i &lt; array.length ; i++)&#123; newArr.push(func(array[i])); &#125; return newArr ;&#125;// 我自己寫的錯誤答案： // var setLimiter = function(limiter) &#123;// 我以為 limiter 會被當作參數傳入（但並不會，因為這裡不是執行函式）// return function(limiter, item)&#123;// return item &gt; limiter ;// &#125;;// 正確解答：var setLimiter = function(limiter) &#123; // 創造函式物件 return function(limiter, item)&#123; return item &gt; limiter ; &#125;.bind(this, limiter);&#125;var arr2 = mapForEach(arr1, setLimiter(2))console.log(arr2); 要特別注意的是，函式 setLimiter 中的 return function(limiter, item) ，其意義為表示式，意思是創造函式物件 function(limiter, item) 後並回傳，並非執行函式 function(limiter, item) 。 所以，函式 setLimiter 傳入的參數 limiter 並不會作為參數傳入函式 function(limiter, item) ，還是要利用 bind() 綁定 limiter 的值，此時， limiter 會根據作用域找到函式 setLimiter 傳進來的參數 limiter 並取用。 這個概念在我自己嘗試解答的時候也混淆了，分清楚創造函式與執行函式，真的很重要！ 最後，講師也提醒我們，在設計函式程式時，盡量不要改變（Mutate）原始的資料（Data），也就是說，注意傳值與物件傳參考的特性，在複製資料時，以深拷貝或創造新的值（物件）來傳遞資料，如 [].push() 、 Object.assign({}, obj) 等方法。 動手寫吧！將你的任務包裝成一個一個的函式，設計屬於你的 JavaScript ！ 結論 函式程式設計的思維是將任務拆分、打包成一個一個的函式（與變數），透過傳入參數的方式，減少重複撰寫程式碼，提升函式的彈性與複用性。 釐清創造函式與執行函式的時機，有利於函式程式設計，瞭解函式作用域、範圍鍊與閉包的原理。 設計函式程式時，盡量不要改變（Mutate）原始的資料（Data），注意物件傳參考的特性，以深拷貝（請見參考資料文章）或創造新物件的方式來傳遞資料。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-51 [Javascript] 關於 JS 中的淺拷貝和深拷貝","link":"/2019/09/04/weird-JavaScript-36/"},{"title":"weird-JavaScript 38：古典繼承 v.s. 原型繼承","text":"與其他程式語言不同，JavaScript 採用原型繼承的方式，將所有物件串聯起來！ 物件導向（Object Oriented）JavaScript 是屬於物件導向的程式語言。 物件導向，指的是，在 JavaScript 中，物件被視為程式組成的基本單元，而且物件之間彼此都會透過繼承的方式互相連結，產生關係，以便資料互相傳遞、取用。 繼承（Inheritance） One object gets access to the properties and methods of another object. 繼承，指的是一個物件取用另外一個物件的屬性或方法。 假設我有兩個物件 ObjA 與 ObjB ， ObjA 繼承了 ObjB ，那麼，我就能在 ObjA 中取用 ObjB 的屬性與方法。 也就是說，當我們創造一個物件時，JS 引擎其實已經將它與另外一個物件連起來，而這個連起來的機制，就是所謂的繼承。 而繼承的方式，主要分為古典繼承與原型繼承兩類。 古典繼承（Classical Inheritance）古典繼承是當代非常主流而熱門的繼承方式， Java 、 C# 等程式語言都是採用古典繼承的設計機制。 古典繼承的特點在於相當口語化（Verbose），而且有非常多的方法可以使用，譬如： friend（夥伴） protected（保護） private（私用） interface（介面） 但古典繼承的弱勢在於，必須瞭解上述規範的方法，才能輕易使用它。 除此之外，古典繼承採用樹狀結構的設計模式，當繼承物件數量增加時，很容易將物件集合成一個大熔爐，讓人搞不清楚內部物件詳細的連結方式。講師將古典繼承比喻成一棟設計複雜的房子，當你想要換燈泡的時候，卻發現馬桶開始沖水，就好像，修改了 A 物件，卻非預期地影響了 B 物件。 原型繼承（Prototypal Inheritance）相較於古典繼承，原型繼承較簡單易懂（easy to understand），且具備彈性（flexible）、可延展（extensible）等優勢。 而 JavaScript 正是透過原型繼承的方式，將所有物件都串聯起來。 往後幾篇會介紹 JS 的原型以及繼承機制。 結論 繼承，指的是一個物件取用另外一個物件的屬性或方法。 JavaScript 屬於物件導向的程式語言，它透過原型繼承的方式，將所有物件都串聯起來。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 5-53 Wiki：物件導向程式設計","link":"/2019/09/07/weird-JavaScript-38/"},{"title":"weird-JavaScript 37：函式程式設計（二）","text":"透過資源庫培養函式程式設計的思維！ 開源教育Underscore 就像 jQuery 一樣，是一個知名的 JavaScript 資源庫（Library），內含許多處理陣列、物件以及函式的語法。 類似功能的資源庫還有後起之秀 Lodash ，它也包括處理陣列、物件以及陣列的語法，且效率更好，速度更快，逐漸取代 Underscore.js 成為主流。 相關連結： Underscore Lodash 課程講師鼓勵我們透過閱讀、解析這些框架（Frame）、資源庫的原始碼，去深入理解函式程式設計的方法與原理，這個過程符合開源教育（Open Source Education）的精神。 我們可以點擊上方連結，到 Underscore 的官方網站，下載 Development（擁有註解） 的版本，並在 Visual Studio 中打開 underscore.js ，從中檢視原始碼撰寫的設計原理。 Underscore.js檢視 underscore.js 的原始碼，我們會發現所有程式碼都被包在一個 IIFE 裡面，保證我們載入這個 Library 後，其內容不會與我們撰寫的程式碼產生衝突。 載入 underscore.js ： 12345678&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; ... &lt;script scr=\"underscore.js\"&gt;&lt;/script&gt; &lt;script scr=\"app.js\"&gt;&lt;/script&gt; // 我們自己撰寫的 JavaScript &lt;/body&gt;&lt;/html&gt; 使用 underscore.js 的語法： 12345678910var arr1 = _.map([1, 2, 3, 4, 5], function(item)&#123; return item * item ;&#125;)var arr2 = _.filter([1, 2, 3, 4, 5, 6], function(item)&#123; return item % 2 === 0 ;&#125;)console.log(arr1) ;console.log(arr2) ; 結論 找各式各樣的 JavaScript 框架或資源庫（Library）來玩，閱讀、理解它們的原始碼，培養程式設計的經驗與感覺。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-52","link":"/2019/09/05/weird-JavaScript-37/"},{"title":"weird-JavaScript 39：原型與原型鍊","text":"來瞭解原型吧！ 上篇我們說過 JavaScript 採用原型繼承的方式，將所有物件連結起來。所以，什麼是原型（Prototype）？ 原型（Prototype）在 JavaScript 中，所有物件，包括函式、陣列，都具有原型屬性 __proto__，原型屬性會參考到另外一個物件，就是所謂的原型物件。 同樣的，原型物件本身也擁有原型屬性，會參考到另外一個物件，即該原型物件的原型物件。 依此類推，每個物件都具備原型物件，我們能藉由取用運算子 . 以及原型屬性 __proto__ 去存取。 透過原型屬性串起來的物件，看起來就像由數個物件串起來的鍊子，我們稱之為原型鍊（Prototype Chain）。 在課程中，講師透過下面這張圖來解釋原型機制： 假設有一個物件 Obj ，我想要存取屬性 Prop3 ，但由於 Obj 本身並沒有這個屬性，所以 JS 引擎會幫我向原型鍊尋找，找到物件 Obj 原型的原型 proto 並取用到屬性 Prop3 。 JS 引擎向原型鍊尋找的過程是隱藏的，也就是說，我只要 Obj.Prop3 ，就能取用到 Prop3 ，而不需要特地 Obj.__proto__.proto__.Prop3 ， 除此之外，假設有另外一個物件 Obj2 ，它可以和物件 Obj 共享同一個原型物件，並取用原型物件具備的屬性或方法，如下圖 Prop2。 先前，我們也提過範圍鍊（Scope Chain），指的是函式執行過程中，當執行環境沒有可用的變數，JS 引擎向外部詞彙環境尋找可取用的變數的過程。 這裡提到的原型鍊（Prototype Chain），指的是物件取用過程中，物件本身沒有可用的屬性或方法，JS 引擎向原型物件尋找可用的屬性或方法的過程。 接著，我們來透過一些程式範例理解原型： 12345678910111213141516171819var person = &#123; firstname: 'Default', lastname: 'Default', getFullName: function()&#123; return this.firstname + ' ' + this.lastname ; &#125;&#125;var Hai = &#123; firstname: 'Hai', lastname: 'An',&#125;// Don't do this EVER !! // 為了展示方便，我們得透過 __proto__ 設定 Hai 的原型，但實務上我們不會這樣做！Hai.__proto__ = person ;console.log(Hai.getFullName());console.log(Hai.firstname); 需要特別注意的是，物件 Hai 呼叫方法 getFullName 後，JS 引擎會創造其函式執行環境，其中的變數 this 會代指呼叫 getFullName 的物件，即 Hai ，而非 person 。 同樣的程式碼，我們加上物件 Jane ： 12345678910111213141516171819202122232425var person = &#123; firstname: 'Default', lastname: 'Default', getFullName: function()&#123; return this.firstname + ' ' + this.lastname ; &#125;&#125;var Hai = &#123; firstname: 'Hai', lastname: 'An',&#125;var Jane = &#123; firstname: 'Jane',&#125;// Don't do this EVER !! // 為了展示方便，我們得透過 __proto__ 設定 Hai 的原型，但實務上我們不會這樣做！Hai.__proto__ = person ;Jane.__proto__ = person ;console.log(Jane.getFullName());console.log(Hai.lastname);console.log(Jane.lastname); 比較 console.log(Hai.lastname); 與 console.log(Jane.lastname); 的差異，可知，如果物件本身已有可用的屬性或方法，JS 就不會向原型鍊尋找。當 JS 引擎在原型鍊中找到可用的屬性或方法，便立即停止搜尋，並回傳該值。 結論 在 JavaScript 中，所有物件，包括函式、陣列，都具有原型屬性 __proto__，原型屬性會參考到另外一個物件，即原型物件。 透過原型屬性串起來的物件，我們稱之為原型鍊（Prototype Chain）。 原型鍊，指的是物件取用過程中，物件本身沒有可用的屬性或方法，JS 引擎向原型物件尋找可用的屬性或方法的過程。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 5-54","link":"/2019/09/08/weird-JavaScript-39/"},{"title":"HTML5 語意標籤","text":"寫了一陣子 HTML ，還是用 &lt;div&gt; 作為切分元素的單位？ 我想，是時候瞭解 HTML5 的語意元素（Semantic Elements）了！ HTML5 語意標籤（Semantic Elements）在 HTML5 以前，開發者常常用區塊元素 &lt;div&gt; 和行內元素 &lt;span&gt; 作為網頁元素的最小單位，搭配合適的 class 或 id 刻出整個網頁，這也是許多初學者一開始認識 HTML 的過程。 你我可能都寫過這樣的網頁架構： 123456789101112131415161718&lt;div class=\"header\"&gt; &lt;h1&gt;頁首標題&lt;/h1&gt; &lt;ul class=\"nav\"&gt; &lt;li&gt;導覽項目 1&lt;/li&gt; &lt;li&gt;導覽項目 2&lt;/li&gt; &lt;li&gt;導覽項目 3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class=\"sidebar\"&gt;側欄內容&lt;/div&gt;&lt;div class=\"content\"&gt; &lt;div class=\"section\"&gt; &lt;div class=\"article\"&gt; &lt;h3&gt;文章標題&lt;/h3&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aliquid temporibus quae voluptatem dignissimos hic nulla laudantium at! Assumenda, ducimus amet?&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;頁尾&lt;/div&gt; 這樣的寫法並沒有什麼不對，但是， &lt;div&gt; 與 &lt;span&gt; 不像 &lt;a&gt; 等元素，可以對瀏覽器表達該元素的內容屬性，好比 &lt;a&gt; 定義了連結， &lt;img&gt; 定義了圖片，而 &lt;h1&gt; 定義了大標題（通常一個網頁頁面只會有一個 &lt;h1&gt;）。 換句話說，就表示網頁架構的功能來看， &lt;div&gt; 與 &lt;span&gt; 並沒有任何意義，也不具備搜尋引擎最佳化（Search Engine Optimization，SEO）的優勢。對開發者來說，我們還要借助 class 或 id 來為元素命名語意，實際上多此一舉。 因此，HTML5 新增許多語意標籤（Semantic Elements），只要掌握這些自帶意義的元素，我們不僅能快速建構一個完整的 HTML 頁面、檢閱程式碼，也有利於搜尋引擎辨識網頁的內容架構，提升 SEO 的效果。 我們可以將上面的範例程式碼轉化成語意標籤，大概會是這個樣子： 1234567891011121314151617181920&lt;header&gt; &lt;h1&gt;頁首標題&lt;/h1&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;導覽項目 1&lt;/li&gt; &lt;li&gt;導覽項目 2&lt;/li&gt; &lt;li&gt;導覽項目 3&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt;&lt;aside&gt;側欄內容&lt;/aside&gt;&lt;main&gt; &lt;section&gt; &lt;article&gt; &lt;h3&gt;文章標題&lt;/h3&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aliquid temporibus quae voluptatem dignissimos hic nulla laudantium at! Assumenda, ducimus amet?&lt;/p&gt; &lt;/article&gt; &lt;/section&gt;&lt;/main&gt;&lt;footer class=\"footer\"&gt;頁尾&lt;/footer&gt; 是不是看起來簡潔多了？ 下面這張圖比較 HTML4 與 HTML5 針對一個部落格頁面所建立的網頁元素結構： （圖片源自參考資料 1.） header The &lt;header&gt; element specifies a header for a document or section.（W3C） 顧名思義， &lt;header&gt; 可以是整個網頁的頁首，也可以是一個 &lt;section&gt; 裡面的頭部區塊。 通常頭部區塊會包含網站標題、副標題、 LOGO 以及導覽列 &lt;nav&gt;。 nav The &lt;nav&gt; element defines a set of navigation links.（W3C） &lt;nav&gt; 指的是網站的主要導覽列，通常一個網頁只會有一個 &lt;nav&gt; ，若網頁中包含其他導覽列（如側欄導覽列），會以 class 另外命名。 main &lt;main&gt; defines the page’s main content. It shouldn’t be enclosed in any of the sectioning tags…There should only be one &lt;main&gt; tag on each page.（Viking Code School） &lt;main&gt; 指的是網頁頁面的主要內容，和 &lt;h1&gt; 類似，通常一個網頁只會有一個 &lt;main&gt; 元素，自然不可能被包覆在 &lt;section&gt; 中。 aside The &lt;aside&gt; element defines some content aside from the content it is placed in (like a sidebar).（W3C） &lt;aside&gt; 指的是與主要內容 &lt;main&gt; 不太相關的區塊，通常是用來放其他內容（如簡介、廣告、次導覽列或相關連結等）的側邊欄位。 section The &lt;section&gt; element defines a section in a document.（W3C） &lt;section&gt; 指的是自訂的區塊，可以搭配 class 作更細緻的命名，譬如一個形象網頁的 Introduction 到最後的 Contact Information： 12345&lt;section class=\"intro\"&gt;&lt;/section&gt;&lt;section class=\"product\"&gt;&lt;/section&gt;&lt;section class=\"service\"&gt;&lt;/section&gt;&lt;section class=\"user-sharing\"&gt;&lt;/section&gt;&lt;section class=\"contact\"&gt;&lt;/section&gt; &lt;section&gt; 通常會包覆一個 &lt;header&gt; 說明該區塊的資訊。我認為 &lt;section&gt; 是有結構意義的 &lt;div&gt; ，一個網頁中可以有許多 &lt;section&gt; ，而 &lt;section&gt; 也可以包覆另外一個 &lt;section&gt;。 article The &lt;article&gt; element specifies independent, self-contained content.（W3C） &lt;article&gt; 顧名思義是一篇文章，但事實上它也可以指自成一格、獨立的內容，譬如一段留言或一段主題討論。 與 &lt;section&gt; 相仿，&lt;article&gt; 通常會包覆一個 &lt;header&gt; 說明該區塊的資訊，一個網頁中也可以有許多個 &lt;article&gt; 。 由於我們無法根據 &lt;section&gt; 與 &lt;article&gt; 的定義去規範明確的巢狀規則，因此，在實務上，我們可能會看到 &lt;section&gt; 裡面有 &lt;article&gt; ，或 &lt;article&gt; 裡面有 &lt;section&gt; 的狀況。 footer The &lt;footer&gt; element specifies a footer for a document or section.（W3C） 同樣的， &lt;footer&gt; 可以是整個網頁的頁尾，也可以是一個 &lt;section&gt; 裡面的尾部區塊。 通常尾部會包含作者、版權、使用條款、聯絡方式等資訊。 HTML5語意元素建構的網頁輪廓最後，引用這張圖片來總結： 參考資料 Viking Code School：HTML5 Semantic W3C：HTML5 Semantic Elements","link":"/2019/09/16/HTML5-semantic-tag/"},{"title":"weird-JavaScript 40：所有東西都是物件（或純值）","text":"欸！ JavaScript 裡面的所有東西都是物件！ 物件、陣列與函式的原型上篇我們談到，所有物件，包括物件、陣列以及函式，都具有原型。 我們可以用這段程式碼來驗證： 1234567var a = &#123;&#125; ;var b = [] ;var c = function()&#123;&#125; ;console.log(a.__proto__) ; console.log(b.__proto__) ; console.log(c.__proto__) ; 執行上面這段程式碼，得到結果如下圖： 我們分別來看一下物件 a 、陣列 b 以及函式 c 的原型。 1. 物件的原型 物件 a 的原型是一個物件，該物件包含一些我們平常在物件中可以取用的方法，如下圖： 以 hasOwnProperty() 為例： 123456var a = &#123; firstname: 'Hai', lastname: 'An'&#125;a.hasOwnProperty('firstname') ; // true 在任何一個物件中，我們可以取用 hasOwnProperty() 來檢測該物件本身是否有某一個屬性，因為所有物件的原型都包含了 hasOwnProperty() 這個方法。 也就是說，所有物件都有原型，指向一個擁有 JS 處理物件方法（如上圖所示）的物件。 我們可以發現，物件 a 的原型裡面並沒有 __proto__ 這個屬性，表示該原型已經是原型鍊的最底層，即基本物件（Base Object）。 2. 陣列物件的原型 我們說過，陣列也屬於物件的一種，可稱之為陣列物件。 陣列 b 的原型是一種陣列物件，該物件也包含一些我們平常在陣列中可以取用的方法，如 push() 、 filter() 、 forEach() 等等： 陣列方法比較多，大家可以試著自己輸入看看。 簡單來說，所有陣列都有原型，指向一個擁有 JS 處理陣列方法（如上圖所示）的物件。 值得注意的是，陣列 b 的原型 b.__proto__ 還有 __proto__ 這個屬性，表示 b.__proto__ 還能向下找到它自己的原型 b.__proto__.__proto__ ，該原型是一個基本物件，即原型鍊最底層的物件。 3. 函式物件的原型 根據一級函式的特性，函式也屬於物件的一種，我們稱為函式物件。 函式 c 的原型是一種函式物件，該物件同樣包含一些我們平常在函式中可以取用的方法，如 call() 、 apply() 、 bind() 等等： 簡單來說，所有函式都有原型，指向一個擁有 JS 處理函式方法（如上圖所示）的物件。 與陣列物件相仿，函式 c 的原型 c.__proto__ 仍有 __proto__ 這個屬性，表示 c.__proto__ 還能向下找到它自己的原型 c.__proto__.__proto__ ，該原型是一個基本物件，即原型鍊最底層的物件。 結論下面這張圖檢驗了 c.__proto__.__proto__ ，結果與 a.__proto__ 和 b.__proto__.__proto__ 相同 ： 我們用邏輯判斷來檢驗這三者是否相同： 1234567var a = &#123;&#125; ;var b = [] ;var c = function()&#123;&#125; ;console.log(a.__proto__ === b.__proto__.__proto__) ; // trueconsole.log(a.__proto__ === c.__proto__.__proto__) ; // trueconsole.log(b.__proto__.__proto__ === c.__proto__.__proto__) ; // true 我們發現，物件、陣列與函式的原型鍊最終會指向同一個基本物件！ 總而言之，除了刻意設定原型，如 setPrototypeOf 、 Object.create() 、 new 等情況以外，JS 引擎會自動幫我們設定物件、陣列與函式的原型，該原型包含一些 JS 內建處理資料的方法。 而無論是哪一種資料型別，資料的原型鍊終點都會指向基本物件！ 咦？你問基本物件的原型是什麼？12var a = &#123;&#125; ;console.log(a.__proto__.__proto__) ; // null 沒錯，就是 null ！ 那你知道 null 屬於什麼資料型態嗎？1typeof null ; // object 欸！就說了， JavaScript 裡面的所有東西都是物件！ 最後，我們可以畫出這張物件、陣列與函式的原型鍊結構： 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 5-54","link":"/2019/09/09/weird-JavaScript-40/"},{"title":"畫出簡單的 SVG 向量圖形","text":"HTML 支援繪製 SVG 向量圖形的功能，究竟要怎麼使用呢？ SVG 向量圖形SVG（Scalable Vector Graphics）指的是可縮放向量圖形，與 JPG 、 PNG 等點陣圖最主要的差異在於。縮放時不會因為圖形解析度而產生模糊，導致邊界出現鋸齒的窘境，因此常用於品牌 LOGO、圖示 Icon 等等。 通常，我們會透過 Adobe Illustrator 繪製 SVG 圖形，但其實，我們也可以直接在 HTML 中繪製 SVG 元素，再搭配上 CSS 屬性，就可以創作出各式各樣的互動式圖案、視覺化圖表，甚至有趣的動畫效果。 這篇文章主要介紹繪製 SVG 基本圖案的語法與屬性，包括 SVG 標籤、直線、文字、圓形、橢圓、矩形以及多邊形，請配合 CodePen DEMO 服用本文。 SVG 標籤與座標系統在 HTML 中， &lt;svg&gt; 表示 SVG 元素，我們可以把 &lt;svg&gt; 的範圍想像成是繪製向量圖案的畫布大小，而每一張 &lt;svg&gt; 畫布都擁有自己的座標系統，用來定位裡面各種圖形的位置。 &lt;svg&gt; 元素的座標原點 (0, 0) 座落元素的左上角，向左方正射出 X 軸，向下方正射出 Y 軸，與 CSS 的 position 屬性定位邏輯相同。 實務上，我們會在 &lt;svg&gt; 原入中設定 viewbox 屬性，來改變 SVG 元素的可視範圍。可以把 viewbox 想像成一個觀景窗（視盒），設定觀景窗的中心點以及大小，就會決定我們觀察 SVG 元素的位置以及大小。 語法：&lt;svg&gt;屬性： viewbox=&quot;min-x min-y width height&quot; min-x：視盒原點 X 座標（第一個值） min-y：視盒原點 Y 座標（第二個值） width：視盒寬度（第三個值） height：視盒高度（第四個值） 這部分範例可以參考 CodePen DEMO 會比較清楚。 直線（Line）語法：&lt;line&gt;屬性： x1：起點 X 座標 y1：起點 Y 座標 x2：終點 X 座標 y2：終點 Y 座標 範例：1234&lt;svg id=\"pic2\" viewbox=\"-100 -100 200 200\"&gt; &lt;line x1=\"-45\" y1=\"-45\" x2=\"45\" y2=\"45\"&gt;&lt;/line&gt; &lt;line x1=\"-45\" y1=\"45\" x2=\"45\" y2=\"-45\"&gt;&lt;/line&gt; &lt;/svg&gt; 搭配 CSS 的 stroke 、 stroke-width 屬性調整 &lt;line&gt; 的顏色與寬度。當然，也可以加上動畫： 12345678910#pic2&#123; stroke: tomato; stroke-width: 10px; transition: all 1s; &amp;:hover&#123; stroke: purple; stroke-width: 10px; &#125;&#125; 圓形（Circle）語法：&lt;circle&gt;屬性： cx：圓心 X 座標 cy：圓心 Y 座標 r：半徑長度 範例：123&lt;svg id=\"pic3\" viewbox=\"-100 -100 200 200\"&gt; &lt;circle cx=\"0\" cy=\"0\" r=\"10\"&gt;&lt;/circle&gt;&lt;/svg&gt; 搭配 CSS 做成動畫（屬性 r 可以寫在 CSS 裡面）： 123456789101112#pic3 circle&#123; fill: black; stroke: transparent; transition: all 1s; &amp;:hover&#123; fill: transparent; stroke: black; stroke-width: 7px; r: 50; &#125;&#125; 矩形（Rectangle）語法：&lt;rect&gt;屬性： x：原點 X 座標 y：原點 Y 座標 width：矩形寬度 height：矩形高度 補充：其實， fill 、 stroke 、 stroke-width 這些屬性也可以加在 HTML 上。範例：123&lt;svg viewbox=\"-100 -100 200 200\"&gt; &lt;rect x=\"-50\" y=\"-50\" width=\"100\" height=\"100\" fill=\"maroon\"&gt;&lt;/rect&gt;&lt;/svg&gt; 橢圓（Ellipse）語法：&lt;ellipse&gt;屬性： cx：橢圓圓心 X 座標 cy：橢圓圓心 Y 座標 rx：橢圓 X 軸半徑 ry：橢圓 Y 軸半徑 範例：123&lt;svg viewbox=\"-100 -100 200 200\"&gt; &lt;ellipse cx=\"0\" cy=\"0\" rx=\"60\" ry=\"30\" fill=\"chocolate\" stroke=\"steelblue\" stroke-width=\"1\"&gt;&lt;/ellipse&gt;&lt;/svg&gt; 折線（Polyline）語法：&lt;polyline&gt;屬性： points=&quot;x1,y1 x2,y2 x3,y3 ...&quot;：節點座標的集合（節點座標不需要用 ; 隔開） 補充： &lt;polyline&gt; 通常會加上 fill=&quot;none&quot; 。範例：123&lt;svg viewbox=\"-100 -100 200 200\"&gt; &lt;polyline points=\"-60,47 -30,55 0,-2 30,-21 60,17 90,29\" fill=\"none\" stroke=\"hotpink\" stroke-width=\"3px\"&gt;&lt;/polyline&gt;&lt;/svg&gt; 文字（Text）語法：&lt;text&gt;屬性： x： X 軸起點 y： Y 軸起點 範例：123&lt;svg viewbox=\"-100 -100 200 200\"&gt; &lt;text x=\"-100\" y=\"0\" fill=\"darkred\"&gt;Use SVG to make an icon!&lt;/text&gt;&lt;/svg&gt; 參考資料 W3C：SVG Tutorial MDN：SVG Tutorial SVG 研究之路 (1) - 初探 SVG","link":"/2019/09/20/svg-introduction/"},{"title":"JS 新手地下城試煉攻略：B1-九九乘法表","text":"為了記錄挑戰 Udemy 課程「JavaScript 題目篇－新手 JS 地下城」的過程，有了接下來一系列的 JS 新手地下城攻略文章。希望可以破台… 第一關要挑戰的是「九九乘法表」，如下圖。 九九乘法表未來這一系列的文章，會先簡單整理開發的步驟和邏輯，再分別以技術或概念來討論。 以第一關的「九九乘法表」來說，步驟為： 撰寫 HTML 的網頁結構，包括「九九乘法表」標題和內容樣板。 利用 CSS 美化「九九乘法表」標題和內容樣板。 透過 JavaScript 載入頁面時自動生成「九九乘法表」內容。 HTML網頁結構分為外層與內層，外層是包住整個九九乘法表的容器，內層則是九九乘法表的內容，也就是九個區塊， 如下方程式碼： 1234567891011121314151617181920212223242526&lt;main class=\"container\"&gt; &lt;!-- 標題區塊 --&gt; &lt;section class=\"title\"&gt; &lt;div class=\"title-decor\"&gt;x&lt;span&gt;&lt;/span&gt;x&lt;/div&gt; &lt;div class=\"title-main\"&gt; &lt;h1&gt;九九乘法表&lt;/h1&gt; &lt;p&gt;MULTIPLICATION TABLE&lt;/p&gt; &lt;/div&gt; &lt;div class=\"title-decor\"&gt;x&lt;span&gt;&lt;/span&gt;x&lt;/div&gt; &lt;/section&gt; &lt;!-- 內容樣板（使用 JavaScript 自動生成） &lt;div class=\"table\"&gt; &lt;h2 class=\"table-title\"&gt;2&lt;/h2&gt; &lt;p&gt;2 x 1 = 2&lt;/p&gt; &lt;p&gt;2 x 2 = 4&lt;/p&gt; &lt;p&gt;2 x 3 = 6&lt;/p&gt; &lt;p&gt;2 x 4 = 8&lt;/p&gt; &lt;p&gt;2 x 5 = 10&lt;/p&gt; &lt;p&gt;2 x 6 = 12&lt;/p&gt; &lt;p&gt;2 x 7 = 14&lt;/p&gt; &lt;p&gt;2 x 8 = 16&lt;/p&gt; &lt;p&gt;2 x 9 = 18&lt;/p&gt; &lt;/div&gt; --&gt;&lt;/main&gt; CSS由於慣用 SCSS 預處理器來寫 CSS ，技術紀錄會以 SCSS 為主。 SCSS-map這次嘗試使用 SCSS 的 map 來儲存變數，它類似於 JSON 格式，可以透過 Key/Value 匹配來儲存數值。 透過 SCSS 的 @function 建構函式，傳入參數，來獲得 map 裡對應的數值，達到管理 SCSS 變數的效果，也方便我們取用。 12345678910111213141516171819202122232425// 管理顏色$colors:( mainGreen: #2EB738, secondGray: #D8D8D8, cardWhite: #FFFFFF, background: #F0F0F0) ;// 使用函式獲得對應的數值@function color($color)&#123; @return map-get($colors, $color) ;&#125;// 管理字體大小$fonts:( sm: 16px, md: 24px, lg: 56px, xl: 128px) ;// 使用函式獲得對應的數值@function font($font)&#123; @return map-get($fonts, $font) ;&#125; Flex排版則使用 Flex ，外層設置為內層一列三個區塊並排，三列共九個，且 flex-wrap: wrap 。 由於設計稿已經給定每個內容區塊的寬高，所以只要算好區塊的 margin 即可，我利用 margin-left: 30px 來推出區塊之間的空間，必須注意的是，每三個（每一列最後一個）就必須讓 margin-left: 0px ，否則第三個會因為空間不足而直接掉到下一列。可以使用 :nth-child(3n) 來處理特定數量的狀況。 為了支援響應式，在視窗小於 1280px 時版面較小，以 margin: 30px 來推出左右等距，平衡視覺。 123456789101112131415161718192021222324.container&#123; max-width: 1280px ; // 最大寬度 1280px margin: 0 auto ; // 左右置中 padding: 45px ; background: color(background) ; // 使用函式獲得對應的數值 @include flex(row) ; // 額外設定 @mixin flex 來包裝 Flex 指令 flex-wrap: wrap ; &gt; div&#123; margin-right: 30px ; @media (max-width: 1280px) &#123; margin: 30px ; &#125; &#125; &gt; div:nth-child(3n)&#123; margin-right: 0px ; @media (max-width: 1280px) &#123; margin: 30px ; &#125; &#125;&#125; 順帶一提， &gt; 在 CSS 中表示只選擇下一層 HTML 元素，而非後代選擇。 至於內容樣板區塊，同樣使用 Flex 排版，flex-wrap: wrap ，但 flex-direction: column ，如此一來，設置好每一個算式的寬高與 padding ，就可以達到兩行並排的效果。 內容樣板的小標題 &lt;h2&gt; 使用了 text-shadow 和 text-stroke ，讓它看起來更為立體。 內容樣板，我給了一個 table 標籤，如下方程式碼： 1234567891011121314151617181920212223242526.table&#123; @include size(350px,366px) ; background: color(cardWhite) ; // 使用函式獲得對應的數值 border-radius: 100px 30px 30px 0 ; box-shadow: 3px 3px 10px color(secondGray) ; margin-bottom: 40px ; display: flex ; flex-direction: column ; flex-wrap: wrap ; p&#123; font-size: font(md) ; // 使用函式獲得對應的數值 color: color(mainGreen) ; // 使用函式獲得對應的數值 text-align: left ; margin: 12.5px 35px ; &#125; h2&#123; font-size: 128px ; color: color(mainGreen) ; // 使用函式獲得對應的數值 font-weight: bold ; text-shadow: 4px 3px 0px color(secondGray) ; -webkit-text-stroke: 2px color(cardWhite) ; text-align: center ; &#125;&#125; JavaScript目的是利用 JavaScript 自動生成九九乘法表的內容，也就是除了大標題以外的八個區塊，重點在於算式的生成，從 2 x 2 = 4 到 9 x 9 = 81。 開發邏輯：利用 for 迴圈來遍歷數字 2 到 9 ，而每一個數字還需要遍歷數字 2 到 9 來生產算式。 整體而言是一個雙層巢狀迴圈，搭配 ES6 的樣板字串（template literal）來生成內容。如下方程式碼： 123456789101112131415161718192021// 外層 for 迴圈for(let i = 2 ; i &lt; 10 ; i++)&#123; // 創造一個新的 div 元素 let tableWrap = document.createElement('div') ; // 將該 div 元素貼上 table 標籤 tableWrap.setAttribute('class','table') ; // 透過樣板字串生成小標 let viewContent = `&lt;h2 class=\"table-title\"&gt;$&#123;i&#125;&lt;/h2&gt;` ; // 內層 for 迴圈 for(let j = 1 ; j &lt; 10 ; j++)&#123; // 透過樣板字串生成算式 viewContent += `&lt;p&gt;$&#123;i&#125; x $&#123;j&#125; = $&#123;i*j&#125;&lt;/p&gt;` ; &#125; // 將生成的內容置入 div 元素中 tableWrap.innerHTML = viewContent ; // 將 div 元素加到 .container 元素最後面（不會取代原本的內容） document.querySelector('.container').appendChild(tableWrap) ;&#125;","link":"/2019/11/30/JS-Underground-B1/"},{"title":"weirdJavaScript 08：作用域、let 與區塊作用域","text":"小飛：「既然範圍鍊能讓函式向外部環境取用變數，那是不是把所有變數都存進全域就好了？超方便DER！」 恰恰相反！實務上，我們會避免污染全域，減少全域變數的產生。 為什麼要避免污染全域？因為實務上，一支 JavaScript 腳本，也就是 .js 檔案，往往會由多位工程師協作撰寫，除此之外，一支 .html 檔案也有可能會載入多支 JS 腳本，在這些多人開發的情況下，如果不同開發者不小心在全域環境中使用了相同的變數名稱，那麼後撰寫或後載入的變數，就會覆寫既有變數的值，導致衝突，不易於管理。 所以，實務上我們會避免污染全域環境，減少全域變數的宣告。 小飛：「意思是盡量要把變數宣告進函式裡，成為區域變數囉？」 可以這麼說，我們利用作用域的特性，將變數存進函式區塊中，等到要用的時候再存取。閉包（Closure）的原理就是從這個概念出發的。我們之後會談到。 作用域（Scope） Where a variable is available in your code. 在 07 篇中我們就已經提過作用域：在函式內宣告的區域變數，只在該函式的執行環境內有效。 換個方式說，詮釋作用域可以詮釋為：一個變數可以被取用的有效範圍。 全域變數因為存在全域環境裡，所以能夠被任何函式取用，也就是範圍鍊的最外層。 區域變數因為被宣告在某一函式裡，所以只能夠在該函式的執行環境內被取用，當然，也能被該函式內的其他函式取用。 這裡要特別闡述「該函式的執行環境內」，指的是大括號 { ... } 所框出的範圍。 所以，我們可以說，函式是切分變數有效範圍（變數環境、作用域）的最小單位。 在 ECMAScript 第六版（俗稱 ES6）發布以前，我們只能用 var 來宣告變數，於是會出現一些弔詭的現象，其中以下面這個範例最為經典： 我希望在五秒內，每一秒就印出一個數字，分別是 0、1、2、3、4 。 新手小飛可能會這樣寫： 12345for(var i = 0 ; i &lt; 5 ; i++)&#123; setTimeout(function()&#123; console.log(i) ; &#125;, 1000) ;&#125; 但是他會發現結果不如預期，這段程式碼執行的結果是：「1 秒後印出五個 5」。 OMG !! WHY ?? 這是因為，當我們在 for 迴圈中使用 var 來宣告 i 時，此時的 i 會被存進全域環境，成為全域變數。 真的？請接續上面程式碼，執行 console.log(window.i) ， JS 會回你 5。 這個例子還要結合非同步回呼的概念來解釋。還記得嗎？ JS 遇到需要時間處理的非同步事件（函式）時，他會先把它丟進事件佇列，等到執行堆疊為空後才處理。 for 跑第一次時， var 宣告 i = 0 ，接著遇到 setTimeout ，JS 把 setTimeout 丟進事件佇列（因為等待 1 秒需要時間），接著迭代 i++ 。然後，開始跑第二次 for ，由於經過 var 宣告的 i 是全域變數，此時 i = 1 會覆寫既有的 0 ， 接著遇到 setTimeout ，JS 又會把 setTimeout 丟進事件佇列… 所以，跑到最後一次，也就是第五次 for 結束時， i = 5 ，全域執行環境也沒東西了，JS 就會回呼執行事件佇列裡面的五個 setTimeout ，而此時 console.log(i) 裡的 i 自然而然等於 5，執行的結果就會印出「五個 5」了。 至於為什麼是「1 秒後」？而不是每 1 秒印出一個 5 ？那是因為 JS 執行很快，五個 setTimeout 在我們看來幾乎同時執行。 所以整體執行結果就會是「1 秒後印出五個 5」。 對非同步回呼的概念應該比較熟悉了吧？ 回到本篇重點，在這個經典範例中，用 var 宣告變數的弔詭現象就是：當我們在 for 迴圈中使用 var 來宣告 i 時，此時的 i 會被存進全域環境，成為全域變數。 仔細觀察會發現，var i = 0 並不在函式大括號 { ... } 裡面，而是在 for( ... ) 中，所以 i 自然會存進全域環境。 2015 年 ES6 新增的 let 宣告，將變數綁定在 { ... } 區塊，更清楚、有效切分作用域和變數環境。 let 與區塊作用域（Block Scope）簡單來說， let 宣告有下列幾個特點： 經過 let 宣告的變數，會將該變數環境綁定在其後的 { ... } 區塊作用域中，包括： function(){ … } for(){ … } if(){ … } 既然如此，我們就可以利用 let 改寫上面那一段程式碼，在 for 中利用 let 宣告 i ，將其作用域綁定在後方 { ... } 中，達到我們預期的目的： 12345for(let i = 0 ; i &lt; 5 ; i++)&#123; setTimeout(function()&#123; console.log(i) ; &#125;, 1000 * i) ; // 乘上 i 是為了延遲函式執行，得到「每 1 秒後」印出一個數字的效果。&#125; 經過 let 宣告的 i 作用域會被綁在 { ... } 區塊中，當 JS 要把 setTimeout 丟進事件佇列時， console.log(i) 裡的 i 已經能夠取用區塊作用域裡的 i ，所以會連同 i 的值一起打包丟進事件佇列。等到 JS 最後執行時，就能夠印出 「0、1、2、3、4」。 必須特別強調的是，在 for 迴圈中，每次跑的區塊都是獨立的，也就是說，for 第一次跑的 { ... } 和第二次跑的 { ... } 並不一樣，每次經過 let 宣告的 i ，在電腦的記憶體位置也不一樣，所以才能被 setTimeout 取用並打包丟進事件佇列。 其實上面這段範例可以利用立即執行函式運算式（IIFE）解構成下面這段程式碼： 12345678910111213141516171819202122// for 跑第一次所建立的 block （執行環境）(function()&#123; let i = 0 ; setTimeout(function()&#123; console.log(i) ; &#125;, 1000 * i) ; &#125;)() ;// for 跑第二次所建立的 block （執行環境）(function()&#123; let i = 1 ; setTimeout(function()&#123; console.log(i) ; &#125;, 1000 * i) ; &#125;)() ;//...// for 跑第五次所建立的 block （執行環境）(function()&#123; let i = 4 ; setTimeout(function()&#123; console.log(i) ; &#125;, 1000 * i) ; &#125;)() ; 經過 let 宣告的變數，無論在哪宣告，都不會被存進全域環境，即便宣告在全域中。 直接用程式碼印證： 123let animal = 'giraffe' ;console.log(animal) ; // giraffeconsole.log(window.animal) ; // undefined（window.animal 找不到任何值） 雖然不會被存進全域，但可以被參考取用： 123456789101112131415let animal = 'giraffe' ;function outer()&#123; let perosn = 'Fei' ; console.log(animal) ; // giraffe function inner()&#123; console.log(animal) ; // giraffe console.log(perosn) ; // Fei &#125; inner() ;&#125;outer() ; 在同個區塊作用域中，只能用 let 宣告一次，且宣告後在區塊中可以被覆寫。 1234567891011121314let animal = 'griaffe' ;function test()&#123; let animal = 'tiger' ; console.log(animal) ; // tiger animal = 'lion' ; console.log(animal) ; // lion &#125;test() ;console.log(animal) ; // giraffe let animal = 'panda' ; // Uncaught SyntaxError: Identifier 'animal' has already been declaredanimal = 'panda' ;console.log(animal) ; // panda 不同區塊作用域中，當然可以用相同名稱 let 宣告變數，因為區塊不同， let 宣告的變數所佔據的記憶體位置就不同。 經過 let 宣告的變數沒有 Hoisting 的特性。 12console.log(animal) ; // Uncaught ReferenceError: Cannot access 'animal' before initializationlet animal = 'griaffe' ; 實務上，現在我們多以 let 宣告來取代 var ，避免對全域環境的污染。 此外， ES6 還有新增另一種語法 const 常數宣告，它的特點幾乎與 let 相同，唯一不同的是，經過 const 宣告的變數無法被覆寫（具有唯讀性），最常被用在賦值 DOM 元素。 結論 實務上，我們會避免污染全域，減少全域變數的衝突發生。 當今我們多用 let 宣告取代 var 來避免污染全域。 經過 let 宣告的變數，會將該變數環境綁定在 { ... } 區塊作用域中。 經過 let 宣告的變數，無論你在哪裡宣告，都不會被存進全域環境。 經過 let 宣告的變數沒有 Hoisting 的特性。 在同個區塊作用域中，只能用 let 宣告一次，且宣告後在區塊中可以被覆寫。 總而言之，函式區塊是切分變數環境（也就是變數作用域）的最小單位。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 2-17、2-18 MDN：let MDN：const 談談 JavaScript 的 setTimeout 與 setInterval 你懂 JavaScript 嗎？#12 函式範疇與區塊範疇（Function vs Block Scope）","link":"/2019/08/09/weird-JavaScript-08/"},{"title":"weirdJavaScript 10：基本型別（純值）與物件型別","text":"JavaScript 將資料分為基本型別與物件型別兩類，那麼 JS 內建的資料型別到底有幾種呢？ 資料型別（Data Type）其實在 02 篇就已經大概介紹過，在 JavaScript 中，資料型別分為兩類： 基本型別／原始型別（純值） 物件型別（物件） 也就是說，在 JS 中，所有的值（Value）都是純值或物件。 更精闢一點地說，所有的值，都是物件。（這個概念比較進階，等到我們更深入瞭解物件後，就能理解。） 這篇主要介紹這兩大資料型別。 基本型別（Primitive） A type of data that represent a single value.(Not an object) 基本型別，又稱原始型別，又細分為六種，每一種都是值（Value），因此基本型別指的就是：「純值」。 什麼意思？相較於物件作為 Name/Value 的集合體，基本型別就只有它這個值（Value）。 而這六種值分別是： 字串（String） a sequence of characters 用單引號（’Fei’）或雙引號（”Fei”）包覆的內容就屬於字串，如 &#39;Fei&#39; 、 &#39;5566&#39; 、 &quot;True&quot; 、 &#39;undefined&#39; 等等。 注意！單引號與雙引號混用是不被接受的： &quot;Fei&#39; 。 我會推薦使用單引號（’’）來表達字串，因為使用雙引號的話，如果字串內容遇到雙引號或其他特殊字元，就必須作跳脫字元（Escape Character）處理，單引號少有這樣的衝突。如下範例： 1234567var noteA = '\"JavaScript\" is not equal to \"Java\"!!' ;var noteB = \"\"JavaScript\" is not equal to \"Java\"!!\" ;console.log(noteA) ; // \"JavaScript\" is not equal to \"Java\"!!console.log(noteB) ; // SyntaxError: Unexpected identifier// 利用反斜線（\\）跳脫字元後，noteB 即可執行：var noteB = \"\\\"JavaScript\\\" is not equal to \\\"Java\\\"!!\" ; 數字（Number） floating point number.Unlike other programming languages, there’s only one ‘number’ type. 和其他語言不同， JavaScript 的數字型別都屬於浮點數（Float）。 除了常見的整數或小數，JS 還包含一些特別的數字： Infinity（無限大） -Infinity（無限小） NaN（不是數字，Not a Number） 任何正數除以 0 都會得到 Infinity ；反之，任何負數除以 0 都會得到 -Infinity。 Infinity 除以 Infinity 會得到 NaN。 0 除以 0 也會得到 NaN。 其實，只要任何運算中出現 NaN ，結果都會是 NaN。 NaN 甚至不等於自己，更別說等於任何數字。但是， NaN 還是屬於數字型別（Number）。 如果你想判斷一個變數或值是不是 NaN ，可以用 isNaN() 來判斷。 1234console.log(NaN === NaN) ; // falseconsole.log(NaN === 100) ; // falseisNaN('NaN') ; // true ；因為 'NaN' 無法轉成其他數字。typeof NaN ; // Number ；NaN 屬於數字型別（Number）。 回到數字型別本身，由於 JS 對 Number 的處理採用的是「IEEE 754」二進位浮點數算術標準，在運算上會出現極其微小的誤差，導致某些運算式的判斷會令人不解，經典案例如下： 1console.log(0.1 + 0.2 === 0.3) ; // false 布林值（Boolean） true or false 斯斯有三種，但 Boolean 只有兩種值： true（是） 和 false（否）。 Boolean 多被用來判斷運算式，藉此控制流程，決定要不要做某一件事，譬如 if ： 1234567var a = 55 ;var b = 66 ;if(a &gt; b)&#123; // 55 &gt; 66 不成立， a &gt; b 會被轉成 false 代入 if，因此 if(false) console.log('a is LARGER than b.') ; // 這段不會執行。&#125;else&#123; console.log('a is SMALLER than b.') ; // 執行這段，印出 a is SMALLER than b. &#125; 在 JavaScript 中，判斷或比較的運算式能夠被隱性轉型成 Boolean ，好比上面這段程式碼中的 `` ，詳細我們不久後就會提到。 空值（Null） null represents lack of exitence. Null 只有 null 這個值，指的是，該變數存在於 JS（記憶體） 中，已經被宣告，可能曾經有值，但現在沒有值。 如果你不想讓一個變數有前述三種值，那麼將它設定為 null 是可以被接受的，因為在必要時，它會被 JS 強制轉型成 0 進行運算。請看下方程式碼： 12345var num = 5566 ;var nul = null ;var und = undefined ;console.log(num + nul) ; // 5566console.log(num + und) ; // NaN ˊ&lt;_ˋ...?????? 未定義（Undefined） undefined represents lack of existence. Undefined 只有 undefined 這個值，指的是，該變數存在於 JS（記憶體） 中，已經被宣告，但尚未被賦值。 一個變數如果是 undefined ，代表變數沒有其他值（字串、數字、null等等），才會被賦值為 undefined。 還記得 Hoisting 嗎？ JS 在 Hoisting 階段時，會先幫我們宣告變數並賦予 undefined ，等到它真正執行後，才真正賦值。 我們可以說， undefined 是 JS 用來告訴我們變數未被賦值的狀況。 注意！請不要將變數賦值為 undefined，因為它需要運算時，會被 JS 強制轉型 為 NaN ，如上方範例。 所以， undefined 真正的意涵，表示變數佔據記憶體位置，但是變數還沒有被賦予其它值。 總結來說，對 JS 而言， null 與 undefined 具有值不存在的意思，但實際上兩者在功能與運算仍有差異，不然何必無緣無故設計兩種型別呢？ Symbol（ES6 新增的型別） Used in ES6. We won’t talk about this here… ES6 後才新增的型別，因為不常見（我也還不會用），這裡先不談。 最後，在介紹物件型別之前，我要先簡單介紹一個很重要的觀念： 在 JavaScript 中，基本型別（上述六種值）的變數賦值或拷貝（Copy）大部分是以傳值（by Value）的方式實現。 聽不懂？沒關係，我們會再細談的。 物件型別（Object）相較於基本型別有六種（純值），物件型別只有一種，就是物件（Object）。 什麼是物件？我們說過，物件是Name/Value（鍵值配對） 的集合體，每一對 Name/Value 都是物件的屬性（Property），其中， Value 可以是其他純值或物件。 創造物件有很多種方式，最常見的是物件實字（Object Literal），我們用程式碼來看會比較清楚： 123456789var person = &#123; // Property: 一組 Name/Value ，其中 Value 是'Fei'（純值） name: 'Fei', // Property: 一組 Name/Value ，其中 Value 是一個物件。 family: &#123; dad: 'Jason', mom: 'Teresa' &#125;&#125; ; 好，重點來了！物件型別只有一種，就是物件（Object），但它擁有次型別（subtype），常見的有這兩個： 陣列（Array），又稱為陣列物件。 函式（Function），又稱為函式物件。 當然還包括其他次型別物件，等我們有遇到再介紹。 所以，物件內容其實可以很複雜： 12345678910111213141516var person = &#123; // Property: 一組 Name/Value ，其中 Value 是'Fei'（純值） name: 'Fei', // Property: 一組 Name/Value ，其中 Value 是一個物件。 family: &#123; dad: 'Jason', mom: 'Teresa', bro: 'Bai' &#125;, // Property: 一組 Name/Value ，其中 Value 是一個陣列，因為陣列也屬於物件的一種。 friends: ['Shiba','giraffe','Fish'], // Method: 一組 Name/Value ，其中 Value 是一個函式，因為函式也屬於物件的一種。 say: function()&#123; console.log('Welcome to my blog!!') ; &#125;&#125; ; 物件中的函式 ，我們稱之為物件的方法（Method），既然是 function ，當然可以呼叫。 使用點運算子（.）取用物件內的屬性或方法： 12console.log(person.name) ; // Feiperson.say() ; // 'Welcome to my blog!!' 之後我們會更深入探討陣列、函式與物件的關係。 簡言之，物件擁有一組以上的屬性（Property）或方法（Method），而屬性和方法也必然符合「鍵值配對」法則。 最後，在進到結論之前，我要先簡單介紹一個很重要的觀念： 在 JavaScript 中，物件型別（也就是物件這一種值）的變數賦值或拷貝（Copy）大部分是以傳參考（by Reference）的方式實現。 傳值（By Value）和傳參考（By Reference）是 JavaScript 處理資料的運作邏輯，也是它偷偷不告訴你的事情之一。 結論 在 JS 中，所有的值（Value）都是純值或物件。 JS 內建的資料型別分兩大類，分別是基本型別與物件型別。 基本型別（Primitive）有六種： 字串（String） 數字（Number） 布林值（Boolean） 空值（Null） 未定義（Undefined） 符號（Symbol，ES6 新增的型別） 物件型別（Object）只有一種，就是物件（Object）。 物件型別包含陣列、函式等次型別，它們都屬於特殊的物件。 所以，JS 內建的資料型別總共有 7 種：6 種純值 + 1 種物件。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 3-20 重新認識 JavaScript: Day 03 變數與資料型別 重新認識 JavaScript: Day 04 物件、陣列以及型別判斷","link":"/2019/08/10/weird-JavaScript-10/"},{"title":"weird-JavaScript 32：閉包（2）","text":"這題沒答對，你敢說你懂閉包？ 閉包概念的程式碼範例請看下面這段程式碼，想一想這段程式碼在做什麼？ 你認為 fs[0]() 、 fs[1]() 、 fs[2]() 執行後，分別會印出什麼數字？ 請將答案紀錄在一張白紙上，再複製貼上這段程式碼至瀏覽器中，檢驗是否正確。 1234567891011121314151617var fs = buildFunctions() ;function buildFunctions()&#123; var arr = [] ; for(var i = 0 ; i &lt; 3 ; i++)&#123; arr.push(function()&#123; console.log(i) &#125;) &#125; return arr ;&#125;fs[0]() ;fs[1]() ;fs[2]() ; 檢驗後答案如你所預期的一樣嗎？如果你答對的話，恭喜你（應該）已經掌握閉包的概念了！ 解釋這個例子的原理之前，有必要畫個防雷分隔線： . . . . . . 沒錯，在這個例子中， fs[0]() 、 fs[1]() 、 fs[2]() 執行後，印出的結果都是 3 。 許多人預期 fs[0]() 、 fs[1]() 、 fs[2]() 會分別印出 0 、 1 、 2 ，怎麼會是 3 ？這數字哪來的？ 簡單來說，這是因為：當你在執行 fs[0]() 這三個函式的時候，它們所參考的外部（詞彙）環境 buildFunctions() 所儲存的區域變數 i ，已經是 3 ，和你創造 fs[0]() 這三個函式的時候的 i 是不一樣的。 還是不懂？沒關係，不用害怕，繼續跟我往下走。 範例解析綜合過去的觀念，我們一步一步拆解這段程式碼在幹嘛。 首先，在 JS 執行程式碼之前，它會做兩件事，你還記得嗎？ Creation： JS 引擎會創造全域執行環境、 window 物件，以及 this 變數（代指 window 物件）。 Hoisting： JS 引擎會將變數宣告與函式宣告儲存進記憶體空間，即創造全域變數與全域函式。在這個例子中，變數 fs 會先被創造並賦值為 undefined ，而函式 buildFunctions() 會被宣告完成。 接著， JS 引擎才會真正開始執行程式碼。而第一行程式碼是： 1var fs = buildFunctions() ; 這行程式碼的意思是： 呼叫函式 buildFunctions ，並將執行後 return 的值賦予給變數 fs 。 所以，我們接著要理解函式 buildFunctions 到底執行了什麼？ 1234567891011function buildFunctions()&#123; var arr = [] ; for(var i = 0 ; i &lt; 3 ; i++)&#123; arr.push(function()&#123; console.log(i) &#125;) &#125; return arr ;&#125; 函式 buildFunctions 被呼叫後，JS 引擎會創造屬於它的執行環境，並開始執行 {} 內部的程式碼（也就是函式物件的程式屬性）。 1var arr = [] ; 宣告一個區域變數 arr 為一個空陣列 []。 12345for(var i = 0 ; i &lt; 3 ; i++)&#123; arr.push(function()&#123; console.log(i) &#125;)&#125; 跑一個 for 迴圈，若符合條件就執行迴圈內容，反之則結束迴圈。 在 for 迴圈這部分，我們宣告一個區域變數 i = 0 當作計數器，若 i &lt; 3，就執行 for {} 內的程式碼，反之則跳出迴圈。 每次在 for {} 裡面，我們要創造一個新的函式 function(){console.log(i)}) ，並將它 push 到變數 arr 陣列裡面。 什麼？你說陣列裡面放函式很怪？忘記我們之前說過：陣列是任何東西的集合，可以存放任何純值或（函式）物件。 我們將每一次迴圈的步驟拆開看： 第一次迴圈時， i = 0 ， 0 &lt; 3 ，符合條件，執行迴圈內容：創造函式 function(){console.log(i)}) 並 push 到 arr 陣列中，接著 i ++ 。 第二次迴圈時， i = 1 ， 1 &lt; 3 ，符合條件，執行迴圈內容：創造函式 function(){console.log(i)}) 並 push 到 arr 陣列中，接著 i ++ 。 第三次迴圈時， i = 2 ， 2 &lt; 3 ，符合條件，執行迴圈內容：創造函式 function(){console.log(i)}) 並 push 到 arr 陣列中，接著 i ++ 。 第四次迴圈時， i = 3 ， 3 &lt; 3 ，不符合條件，跳出迴圈， for 迴圈結束。 此時，區域變數 arr 為一個陣列，裡面包括三個函式（物件），而區域變數 i = 3 。 1return arr ; 回傳變數 arr 陣列。 至此，函式 buildFunctions 執行完畢，JS 引擎會消滅屬於它執行環境。 但是！上篇我們有說，JS 引擎會保留儲存函式參數與區域變數的記憶體空間，也就是說，區域變數 arr 和 i 仍會存於該函式專屬的記憶體空間，並不會消滅。 回到全域執行環境，函式 buildFunctions 執行後回傳變數 arr 陣列，並賦值給變數 fs 。 因此 fs = arr 。（想一想，是傳值？還是傳參考？） 終於來到最後一步： 123fs[0]() ;fs[1]() ;fs[2]() ; 依序呼叫變數 fs 裡的三個函式並執行。 fs[0] 、 fs[1] 、 fs[2] 三個函式都指向函式 function(){console.log(i)}) ，以 fs[0]() 為例，JS 執行後，會創造其專屬的執行環境，並開始執行程式： 123function()&#123; console.log(i)&#125; JS 引擎知道要執行 console.log(i) ，於是開始在函式 function(){console.log(i)}) 裡面找 i，但很顯然，它找不到（因為沒有定義），所以它只好依照範圍鍊的規則，向外部（詞彙）環境尋找可以取用的 i 。 外部詞彙環境是誰？想一想，我們在哪裡創造函式 function(){console.log(i)}) ？ 沒錯！就是在函式 buildFunctions 裡面！ 1234567891011function buildFunctions()&#123; var arr = [] ; for(var i = 0 ; i &lt; 3 ; i++)&#123; arr.push(function()&#123; console.log(i) &#125;) &#125; return arr ;&#125; 所以，JS 引擎會參考外部（詞彙）環境函式 buildFunctions 裡的區域變數 i 。 此時 i 是多少？ i = 3 。 按此邏輯， fs[0]() 、 fs[1]() 、 fs[2]() 印出的結果當然都會是 3 了。 創造函式 v.s. 執行函式有些人之所以預期執行結果為 0 、 1 、 2 ，那是因為混淆創造函式和執行函式的時機與差異。 其實，我認為只要釐清創造函式和執行函式的時機與差異，閉包的原理就很清晰了。 在這個例子中，創造函式 function(){console.log(i)}) 的時候，就只是單純創造該函式而已，並不會將外部環境的變數 i 一起存進記憶體。 等到執行函式時， JS 引擎在函式執行環境 function(){console.log(i)}) 中找不到可用的 i（因為它函式內部本身並沒有宣告 i 值），所以它會依照範圍鍊，向外部詞彙環境參考可用的值。 外部詞彙環境，指的就是，我們在哪裡創造函式？或說，函式被我們寫在哪裡？ 綜合 JS 種種的特性，形成了閉包的原理：利用函式執行環境，創造一個封閉空間，包住可供取用的變數。而那些在範圍鍊中可供取用的變數，又稱為自由變數（Free Variable） 總而言之，分清楚創造（宣告）函式與執行（呼叫）函式的時機以及差異，有助於理解閉包的原理，因為閉包就是綜合這些概念而來。 課程中用這張圖來解釋本篇範例的運作原理： 結論 分清楚創造函式與執行函式的時機以及差異，有助於理解閉包的原理。 創造函式時， JS 引擎會創造該函式的記憶體空間，並儲存函式內宣告的變數，並不會將外部環境的自由變數一起存進記憶體（除非以參數傳入）。 執行函式時， JS 引擎如果在函式執行環境中找不到可取用的值，它會依照範圍鍊向外部詞彙環境參考可用的值，直到找到為止。 閉包的原理就是：利用函式執行環境，創造一個專屬的封閉空間（記憶體空間），包住可供取用的變數。 自由變數指的是：函式在範圍鍊中可供取用的變數。 參考資料 JavaScript 全攻略：克服 JS 奇怪的部分 4-47","link":"/2019/08/26/weird-JavaScript-32/"},{"title":"JavaScipt 陣列方法的 20 道陰影","text":"本文為普遍級，適合闔家觀賞。 JavaScript 陣列方法無論哪一個程式語言，處理資料的時候難免會碰到陣列，對陣列方法不熟悉的初學者，很容易陷入焦慮，因此，有效掌握陣列方法，絕對事半功倍！ 我在網路上看到有許多前輩整理陣列方法的文章，也決定自己寫一篇，作為未來方便查找的紀錄。 下面引用了 tooto1985 畫的圖，整合了常見的 JS 陣列方法，讓人印象深刻。 以下就逐一介紹 JavaScript 中常見的陣列方法（Array Methods），主要聚焦說明方法功能、語法參數以及簡單範例。 concat()功能：合併兩個以上的陣列。語法：concat(Array)範例：1234var Array = ['a', 'b', 'c'] ;var ArrayConcat = [1, 3, 5, 7, 9] ;console.log(Array.concat(ArrayConcat)); push()功能：在尾端陣列增加多個值。語法：push(Value1, Value2...)補充： 若增加的是物件，必須注意傳參考特性。範例：1234var Array = ['a', 'b', 'c'] ;Array.push('c',777, ['55', 66], &#123;name: 'Fei'&#125;);console.log(Array) ; pop()功能：移除陣列最後一個值。語法：pop()範例：12var Array = ['a', 'b', 'c'] ;console.log(Array.pop()); shift()功能：移除陣列第一個值。語法：shift()範例：12var Array = ['a', 'b', 'c'] ;console.log(Array.shift()); unshift()功能：在陣列頭端新增多個值。語法：unshift(Value1, Value2...)範例：1234var Array = ['a', 'b', 'c'] ;Array.unshift('c',777, ['55', 66], &#123;name: 'Fei'&#125;);console.log(Array) ; splice()功能：刪除陣列裡的數個值（並同時在該區段中插入數值）。語法：splice(startIndex, deleteNum, valueAdd...)範例：1234var Array = ['x', 'y', 'z', 55 ,66] ;Array.splice(0, 3, 1314, '520');console.log(Array) ; join()功能：將陣列所有值透過 Separator 串成一個字串後回傳。語法：join(separatorString)範例：123456var Array = [55, 66, '520'] ;console.log(Array.join()); // 預設為 ,console.log(Array.join(''));console.log(Array.join(' '));console.log(Array.join('-')); forEach()功能：將陣列裡的每個值逐一傳入給定的函式執行。語法：forEach(function(Value, Index, Array){ ... }) function(){...}：給定的函式 Value：目前被函式處理的值 Index：目前被函式處理的值的索引值 Array：陣列本身 範例：123456var Array = [1, 3, 5, 7, 99] ;Array.forEach(function(item, index)&#123; console.log(item * index) ;&#125;);console.log(Array) ; map()功能：將陣列裡的每個值逐一傳入給定的函式，執行後回傳，產生新的陣列。語法：map(function(Value, Index, Array){ ... }) function(){...}：給定的函式 Value：目前被函式處理的值 Index：目前被函式處理的值的索引值 Array：陣列本身 範例：12345678910var Array = [1, 3, 5, 7, 99] ;ArrayNew = Array.map(function(item)&#123; return item * item ;&#125;);// ES6 箭頭函式簡化// ArrayNew = Array.map(item =&gt; item * item);console.log(Array, ArrayNew) ; reduce()功能：將陣列裡的每一個數值加總後回傳。語法：reduce(function(Accumulator, currentValue){ ... }) function(){...}：給定的函式 Accumulator：目前累加的數值 currentValue：目前被處理的數值 範例：12345var Array = [1, 3, 5, 7, 99] ;totalNum = Array.reduce((prev, next) =&gt; prev + next);console.log(totalNum) ; sort()功能：對陣列內的數值進行排列。排列方法：將數值轉化為字串（String），並根據字元的 Unicode 進行排序。語法：sort()範例：1234567var Array1 = [1984, 3, 55, 777, 99, 123] ;var Array2 = ['Nov', 'Oct', 'Apr', 'May', 'Jul'] ;var Array3 = [5, 6, 3, 1, 9, 10] ;console.log(Array1.sort()) ;console.log(Array2.sort()) ;console.log(Array3.sort()) ; reverse()功能：將陣列數值順序反轉。語法：reverse()範例：12345var Array1 = [1984, 3, 55, 777, 99, 123] ;var Array2 = ['Nov', 'Oct', 'Apr', 'May', 'Jul'] ;console.log(Array1.reverse()) ;console.log(Array2.reverse()) ; filter()功能：將陣列裡的每個值逐一傳入給定的函式進行過濾，回傳符合條件的值，產生新的陣列。語法：filter(function(Value, Index, Array){ ... }) function(){...}：給定的函式 Value：目前被函式處理的值 Index：目前被函式處理的值的索引值 Array：陣列本身 範例：12345var Array = [1984, 3, 55, 777, 99, 123] ;var filteredArr = Array.filter(value =&gt; value &gt; 100);console.log(filteredArr) ; find()功能：將陣列裡的每個值逐一傳入給定的函式進行篩選，回傳第一個符合條件的值。語法：find(function(Value, Index, Array){ ... }) function(){...}：給定的函式 Value：目前被函式處理的值 Index：目前被函式處理的值的索引值 Array：陣列本身 範例：12345var Array = [1984, 3, 55, 777, 99, 123] ;var foundValue = Array.find(value =&gt; value &gt; 100);console.log(foundValue); every()功能：將陣列裡的每個值逐一傳入給定的函式，若所有值都符合條件就回傳 true ，否則回傳 false。語法：every(function(Value){ ... }) function(){...}：給定的函式 Value：目前被函式處理的值 範例：12345var Array = [1984, 3, 55, 777, 99, 123] ;var result = Array.every(value =&gt; value &lt; 1999);console.log(result); every()功能：將陣列裡的每個值逐一傳入給定的函式，若所有值都符合條件就回傳 true ，否則回傳 false。語法：every(function(Value){ ... }) function(){...}：給定的函式 Value：目前被函式處理的值 範例：12345var Array = [1984, 3, 55, 777, 99, 123] ;var result = Array.every(value =&gt; value &lt; 1999);console.log(result); includes()功能：判斷陣列中是否包含特定的值，是就回傳 true ，否則回傳 false。語法：includes(specificValue)範例：12345var Array = [1984, 3, 55, 777, 99, 123] ;var result = Array.includes(5566);console.log(result); indexOf()功能：尋找陣列中符合給定值的索引值，若找不到就回傳 -1。語法：indexOf(specificValue, startIndex) specificValue：給定值 startIndex：從哪個索引開始找 補充： startIndex 可以輸入負值（陣列最後一個值為 -1），但仍會由左至右開始找。 可用於字串（String）。 範例：12345678var Array = ['Fei', 'Bai', 'Han', 'Chu', 'Bubu'] ;var Str = 'Ed Sheeran' ;console.log(Array.indexOf('Fei', 2));console.log(Array.indexOf('Chu', 2));console.log(Array.indexOf('Bai', -5)); // 1console.log(Str.indexOf(' ', 1)); console.log(Str.indexOf('e', 1)); slice()功能：擷取陣列的某一個區段。語法：slice(startIndex, endIndex) startIndex：從哪個索引值的值開始擷取 endIndex：從哪個索引值的值開始不擷取（即不會擷取到 endIndex 的值） 補充： 可用於字串（String）。 範例：123456var Array = ['Fei', 'Bai', 'Han', 'Chu', 'Bubu'] ;var Str = 'Ed Sheeran' ;console.log(Array.slice(1,4));console.log(Str.slice(0,2)); console.log(Str.slice(3)); for…of功能：遍歷陣列中的每一個值，與 forEach() 類似。語法：for(let value of Array){ ... }補充： 可用於字串（String）。 與 for..in 完全不同， for..in 只能用在物件，用來遍歷其所擁有的 Property Name。 範例：123456789101112var Array = ['Fei', 'Bai', 'Han', 'Chu', 'Bubu'] ;var Str = '1234567890' ;for (let value of Array) &#123; value += ' &lt;3' ; console.log(value);&#125;for (let char of Str) &#123; char += ' !?' ; console.log(char); &#125; 小叮嚀 若方法需要給定函式，須注意函式中 this 代指的對象。 若方法會改變陣列資料，如新增或移除，必須注意資料傳值與傳參考特性。 若方法會改變陣列資料，必須注意是否變更原始陣列？還是產生一個新的陣列？ 參考資料 tooto1985：js-array-operations Day2-陣列操作常用的20個函式","link":"/2019/09/20/20-shadows-of-array/"},{"title":"2020 口罩存貨實時地圖開發紀錄","text":"這篇文章主要是想記錄這次「2020 口罩存貨實時地圖」的開發過程。從 2/6 衛服部健保署釋出 API ，趕緊串接資料釋出簡易的存貨熱點，到今天開發告一段落，這中間從摸索地圖資料、理解 JavaScript ES6 的 Promise 等等，著實學到蠻多東西，也順便複習原生的 JS 語法。 目前開發成果如下圖，作品請參考連結，開源程式碼請詳見 GitHub ，更多資訊可查詢口罩供需資訊平台。 本文主要紀錄以下幾個技術面向： 使用 leaflet.js 與 OpenStreetMap 搭建地圖資料 透過 JavaScript ES6 Promise 語法串接 API 使用 Leaflet.markercluster 群集化資料 縣市／鄉鎮市區／關鍵字篩選功能實作 透過 Geolocation 取得使用者的位置資訊 收藏功能實作 好，我們開始吧！ 使用 leaflet.js 與 OpenStreetMap 搭建地圖資料leaflet.js 是一款開源的 JS 函式庫，可以快速搭建支援響應式的地圖介面，其官網中的 Leaflet Quick Start Guide 概略地介紹如何使用 leaflet.js 。 首先，透過 CDN 在 HTML 檔案的 &lt;head&gt; 區塊載入資源包： 1234&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" /&gt; &lt;script src=\"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\"&gt;&lt;/script&gt;&lt;/head&gt; 當然，也可以透過 NPM 來載入：npm install leaflet 。 在 HTML 中透過 id 來指向地圖所要搭建的區塊，CSS 中也要先指定高度： 1&lt;div id=\"map\"&gt;&lt;/div&gt; 1#map &#123; height: 100vh; &#125; 接著，我們就能在 JS 中初始化地圖，並加入圖磚圖層（Tile Layer），所謂圖磚圖層，指的是地圖本身的圖層，而為何特地以「圖磚」形容，那是因為地圖資料都是由一張張正方型圖片所拼貼起來的，就像磚塊一樣，如下面這張圖，仔細觀察有縱橫交錯的線，那就是圖磚之間的間隙。 回到正題。由於 leaflet.js 本身沒有地圖資料，所以必須透過第三方圖資來渲染圖層。官方建議的圖資有 OpenStreetMap（OSM） 和 Mapbox ，其中，後者和 Google Map API 相同，需要串接個人註冊申請的 Access Token ，倘若流量超過，就必須綁定信用卡加以計費（台南好想工作室 Howard 的 60 萬帳單就是這麼來的）。因此，這裡選擇使用 OSM 的圖資 API 。 1234567891011121314// 初始化const map = L.map('map', &#123; center: [25.040065, 121.523235], // 台北市區的經緯度（地圖中心） zoom: 10, // 地圖預設尺度 zoomControl: false // 是否顯示預設的縮放按鈕（左上角）&#125;) // 新增圖資圖層（OSM 圖資）const osmUrl = 'https://&#123;s&#125;.tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png';L.tileLayer(osmUrl, &#123; attribution: 'Map data &amp;copy; &lt;a href=\"https://www.openstreetmap.org/\"&gt;OpenStreetMap&lt;/a&gt; | 資料來源：&lt;a href=\"https://data.nhi.gov.tw/Datasets/DatasetResource.aspx?rId=A21030000I-D50001-001&amp;fbclid=IwAR11LdkhQPr1nyASKg0bUCx6LnIGY7KECOeVQ2EHwc67f2iKocIMuXRIpFE\"&gt;衛生福利部中央健康保險署&lt;/a&gt; | Created by &lt;a href=\"https://www.facebook.com/luffychen0715?ref=bookmarks\" target=\"_blank\"&gt;Fei&lt;/a&gt;', minZoom: 8, // 最小縮法尺度 maxZoom: 18 // 最大縮放尺度&#125;).addTo(map); 如此一來，我們便完成地圖的初步搭建。當初用 OSM 搭建完地圖後，總覺得 OSM 的圖資塞滿太多圖例（Legend），很干擾主要資料的視覺化。所以我 Google 好一陣子有沒有客製化 OSM 圖例的方法，但解方似乎太過複雜而最後作罷。如果是以 Mapbox 作為圖資，其實是可以客製化圖例的，但我不想負擔 Mapbox API 的流量。 不過，幸運的是，有前輩看到我的初版作品，建議我可以透過 CSS 的 filter 來調整 OSM 的圖磚色調，降低背景干擾，也不失為一種解決方案。不愧是前輩，太神啦！ 1234// OSM 圖資的對比與亮度.leaflet-tile-pane &#123; filter: grayscale(0.7) contrast(0.5) brightness(0.7); &#125; 眼尖的朋友應該有發現，我取消了預設的地圖縮放鈕，因為我想客製化縮放鈕在地圖的右上角： 1234// 自訂縮放按鈕位置L.control.zoom(&#123; position: 'topright'&#125;).addTo(map); 接著，我們可以試著在地圖上畫出一個座標： 123L.marker([25.040065, 121.523235]).addTo(map) .bindPopup('A pretty CSS3 popup.&lt;br&gt; Easily customizable.') .openPopup(); .bindPopup() 的參數可以放入一段 HTML 字串， JS 會將它渲染成該座標的 Popup （冒泡視窗）元素。 如果想要換掉座標 Icon 的顏色，可以參考 Thomas Pointhuber 所製作的模板，或是自己準備圖檔（ PNG 等等），客製化自己的 Icon 。我參考 Thomas 的寫法， Icon 的初始化封裝進一個建構函式，在分別創造不同的 Icon ： 123456789101112131415// 建議使用 Thomas 設定的參數，沒有遇到 Icon 變形的問題。function createIcon(name) &#123; return new L.Icon(&#123; iconUrl: `./Assets/$&#123;name&#125;.png`, iconSize: [41, 41], // 根據 Icon 的大小自行調整 iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] &#125;);&#125;const greenIcon = createIcon('flag-green');const orangeIcon = createIcon('flag-orange');const redIcon = createIcon('flag-red');const userPosIcon = createIcon('user'); 至此，我客製化了理想中的地圖，接著處理資料的部分。 透過 JavaScript ES6 Promise 語法串接 API這次要獲取的資料總共有兩份： 口罩即時存量資料，我用的是 Kiang 整理的 GeoJSON 檔案。 全台縣市鄉鎮資料，我用的是 Donma 整理的台灣縣市／鄉鎮／地址中英文 JSON 。 這裡我使用 JS 原生的 AJAX（Asynchronous JavaScript and XML） XMLHttpsRequest 物件串接 API 來獲得資料。至於為什麼要使用 Promise 呢？這是為了確保 JS 執行完從遠端抓資料這個異步行為後，再繼續執行後面的事情。因為 JavaScript 本身的程式設計是單執行緒且同步執行的（JS 一次只能做一件事，一件一件執行）。 從開發的邏輯來思考，一定是先有資料，才能進行資料視覺化。為了避免 JS 進行資料視覺化時找不到資料的窘境（JS 尚未獲得資料，因為獲取資料需要時間），所以我們需要 Promise 來「保證」獲得資料這個異步行為執行完畢。 簡單來說， Promise 物件有三種狀態，分別是等待（Pending）、實現（Fulfilled）以及拒絕（Rejected），串起來就是 Promise 的生命週期。 在 *Promise 中，我們可以自定義異步行為。當 *Promise 初始化（實體化）後，首先處於 Pending 狀態，並根據執行結果，將所獲取的資料傳入解決（resolve）或拒絕（reject）兩個回呼函式（Callback Function），改變 Promise 物件的狀態，作為判斷異步行為的執行狀況。接著，再以 Promise.then() 來定義後續的行動。 由於我們要取得兩份資料，代表有兩個 AJAX 異步事件需要執行。因此，我們可以使用 Promise.all() 來保證兩則異步事件都執行完畢後， JS 再繼續往下執行： 1234567891011121314151617181920212223242526// 將 Promise 初始化封裝成一個函式function getXML(path) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhrReq = new XMLHttpRequest(); xhrReq.onload = function() &#123; if(xhrReq.status == 200) &#123; const data = JSON.parse(xhrReq.response); resolve(data); // 獲取資料後，將資料傳入 resolve() 。 &#125; else &#123; console.log('抱歉，現在無法取的即時資訊！'); &#125; &#125;; xhrReq.open('GET', path); xhrReq.send(); &#125;)&#125;const getCityDatas = getXML('./CityCountyData.json');const getStoreDatas = getXML('https://raw.githubusercontent.com/kiang/pharmacies/master/json/points.json?fbclid=IwAR0RC0E5_D-1vZVHJX_wvm7VUvdHYYcGw2Q0sSk4ppxu1zvqh7hAWN0oHdU');Promise.all([getCityDatas, getStoreDatas]).then(resultDatas =&gt; &#123; const cityDatas = resultDatas[0]; const storeDatas = resultDatas[1].features; // ...&#125;) 關於 Promise 語法的詳細解說，可以參考從Promise開始的JavaScript異步生活（點擊 Download PDF 即可下載），我覺得是一份很仔細的說明文件。 使用 Leaflet.markercluster 群集化資料檢視從遠端取得的資料，可以知道這是由 6864 個物件所組成的陣列，一個物件儲存一家口罩販售據點的資訊，包括藥局名稱、電話、地址、口罩即時存量等等。 試想，如果我們一次渲染 6864 個座標（包含 Popup 和 Icon ）在地圖上，想必網頁載入時間會非常久（我用 Chrome 實測至少超過 30 秒）。所以，我們可以使用 Leaflet.markercluster 這個插件將資料群集化，在小比例尺時顯示較少資料，等到我們放大地圖時才顯示詳細的資料，避免一次渲染過多資料而拖慢網頁載入時間，也提升使用者體驗。 使用之前要先載入資源包： 12345678&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.4.1/MarkerCluster.css\"&gt; &lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.4.1/MarkerCluster.Default.css\"&gt;&lt;/head&gt;&lt;body&gt;... &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.4.1/leaflet.markercluster.js\"&gt;&lt;/script&gt;&lt;/body&gt; 1234567891011// 初始化一個 MarkerClusterGroupconst storeCluster = new L.MarkerClusterGroup(&#123; spiderfyOnMaxZoom: true, showCoverageOnHover: false, zoomToBoundsOnClick: true, // 自訂群集樣式 iconCreateFunction: function(cluster) &#123; return L.divIcon(&#123; html: `&lt;div class=\"store-cluster\"&gt;$&#123;cluster.getChildCount()&#125;&lt;/div&gt;` &#125;); &#125;&#125;).addTo(map); 群集的 Icon 可以透過 CSS 自訂樣式： 12345678910.store-cluster &#123; @include size(50px); border-radius: 50%; line-height: 50px; font-size: 14px; text-align: center; font-weight: bold; border: 1.5px solid rgba(#000, 0.7); background-color: rgba(#fff, 0.5);&#125; 縣市／鄉鎮市區／關鍵字篩選功能實作因為整個口罩地圖都是用原生 JS 開發的，所以縣市／鄉鎮市區的選項也是透過 JS 印製出來。 replace() 和 Regex 整理字串台灣縣市／鄉鎮／地址中英文 JSON 檔案裡使用的是繁寫「臺」，我用 Regex 清理置換成 「台」字（其實直接改檔案就好了…）： 1const cityArray = cityDatas.map(item =&gt; item.CityName.replace(/臺/g,'台')); 刪除陣列中特定值的方法資料裡面也包含「海南島」和「釣魚台」兩個地方，因為用不到，所以必須篩除。「刪除陣列中特定值的方法」其實有很多，這裡只記錄一個，我把它模組化成一個函式，得以重複使用： 12345678910function removeByValue(array, value) &#123; return array.forEach((item, index) =&gt; &#123; if(item === value) &#123; array.splice(index, 1); &#125; &#125;)&#125;removeByValue(cityArray, '南海島');removeByValue(cityArray, '釣魚台'); 刪除陣列中重複值的方法有時候清理資料時，也會篩除陣列中重複的數值，這邊順道記錄一種方法： 123const noRepeatCityArray = cityArray.filter((item, index, arr) =&gt; &#123; return arr.indexOf(item) === index;&#125;) 用 include() 匹配選項和關鍵字篩選功能中 DOM 元素的監聽事件是透過 change 來綁定回呼函式，就不多加贅述。值得一提的是「篩選邏輯」的部分，無論是選項或關鍵字，只要使用 filter() 和 include() 就能實作出來： 123456789101112// 透過縣市搜尋matchedStore = stores.filter(store =&gt; store.properties.address.includes(citySelected));// 透過縣市和鄉鎮市區搜尋matchedStore = stores.filter(store =&gt; store.properties.address.includes(citySelected + areaSelected));// 透過關鍵字搜尋storeDatas.filter(store =&gt; &#123; if(store.properties.address.includes(searchValue) || store.properties.name.includes(searchValue)) &#123; // ... &#125;&#125;) 將資訊樣板封裝成函式以便彈性呼叫因為無論哪一種搜尋，都需要印出搜尋結果，既然重複好幾次，那就模組化成一個函式吧！ 12345678910111213141516171819202122232425262728function createHTML(store, html, count, loved = false) &#123; let [bgAdultColor, bgChildColor] = ['#bfffbf', '#bfffbf']; // 綠 // ... html += ` &lt;div class=\"store-info p-3\" data-lat=\"$&#123;store.geometry.coordinates[1]&#125;\" data-lng=\"$&#123;store.geometry.coordinates[0]&#125;\"&gt; &lt;div class=\"d-flex justify-content-between\"&gt; &lt;h5 class=\"font-weight-bold mb-2\"&gt;$&#123;store.properties.name&#125;&lt;/h5&gt; &lt;div class=\"love $&#123;loved ? 'hide' : ''&#125;\"&gt;&lt;i class=\"far fa-heart\"&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class=\"loved $&#123;loved ? 'show' : ''&#125;\"&gt;&lt;i class=\"fas fa-heart\"&gt;&lt;/i&gt;&lt;/div&gt; &lt;/div&gt; &lt;p class=\"mb-1\"&gt;&lt;i class=\"fas fa-map-marker-alt\"&gt;&lt;/i&gt; &lt;a href=\"https://www.google.com.tw/maps/place/$&#123;store.properties.address&#125;\" target=\"_blank\"&gt;$&#123;store.properties.address&#125;&lt;/a&gt;&lt;/p&gt; &lt;p class=\"mb-2\"&gt;&lt;i class=\"fas fa-phone-alt\"&gt;&lt;/i&gt; $&#123;store.properties.phone&#125;&lt;/p&gt; &lt;div class=\"masks-info\"&gt; &lt;div class=\"mask-item\" style=\"background-color: $&#123;bgAdultColor&#125;\"&gt;成人口罩 &lt;span&gt;$&#123;store.properties.mask_adult&#125;&lt;/span&gt; 個&lt;/div&gt; &lt;div class=\"mask-item\" style=\"background-color: $&#123;bgChildColor&#125;\"&gt;兒童口罩 &lt;span&gt;$&#123;store.properties.mask_child&#125;&lt;/span&gt; 個&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;hr class=\"m-0\"&gt; `; count += 1; return [html, count];&#125;// 印出搜尋結果[str, storeCount] = createHTML(store, str, storeCount);// 印出收藏的藥局[str, storeCount] = createHTML(store, str, storeCount, true); 其實這部分的重點在 include() 這個語法，它不僅是字串的方法，也是陣列的方法，太好用了！ 另外一個重點也告訴我，還是趕快把框架學會吧（哭）。還有，陣列方法也要熟悉！（推薦閱讀：JavaScript Array 陣列操作方法大全 ( 含 ES6 )） 透過 Geolocation 取得使用者的位置資訊取得使用者地理位置資訊的方法也有很多種，這次嘗試的是地理位置定位 (Geolocation) 物件。透過 Geolocation API 取得使用者地理位置需要經過同意，當使用者進入網站時，瀏覽器就會跳出一個對話框詢問，如下圖。其他方法應該可以有客製化的 Modal ，未來有機會再研究。 MDN 仔細介紹了 Geolocation 的用法，這裡就稍微紀錄一下程式碼，一樣，模組化成函式： 123456789101112131415161718192021function getUserPosition() &#123; // 檢查瀏覽器是否支援 Geolocation API if(navigator.geolocation) &#123; // 定義成功的回呼函式 function showPosition(position) &#123; L.marker([position.coords.latitude, position.coords.longitude], &#123;icon: userPosIcon&#125;).addTo(map); map.setView([position.coords.latitude, position.coords.longitude], 16); &#125; // 定義失敗的回呼函式 function showError() &#123; console.log('抱歉，現在無法取的您的地理位置。') &#125; navigator.geolocation.getCurrentPosition(showPosition, showError); &#125; else &#123; console.log('抱歉，您的裝置不支援定位功能。'); &#125;&#125; 收藏功能實作Local Storage 暫存收藏藥局資料部分，就是很單純將用戶所收藏的藥局的電話暫時存進瀏覽器的 Local Storage 中，等到需要時再抓回來用（後來我實作用戶到訪網站時直接渲染收藏藥局清單，方便使用者，也提升載入速度）。必須注意的是，資料存進 Local Storage 前後，都必須格式化處理： 12345// 從 Local Storage 載入資料const lovedStores = JSON.parse(localStorage.getItem('lovedStores')) || [];// 將資料存進 Local Storage localStorage.setItem('lovedStores', JSON.stringify(lovedStores)) ; 原生 JS 新增／移除 HTML 中的 class之前慣用 jQuery 處理 DOM ，這次嘗試用原生 JS 新增或移除標籤，其實兩者大同小異，都有 add 、 remove 、 toggle 方法，只不過原生 JS 是以 classList 來儲存 DOM 的標籤。 除此之外，原生 JS 的 DOM 選取器也可以熟悉一下。（還是趕快綁框架學起來…） 123456789101112131415161718192021222324function loveBtnActive() &#123; const love = document.querySelectorAll('.store-info .love'); const loved = document.querySelectorAll('.store-info .loved'); love.forEach(el =&gt; &#123; const lovedStoreTel = el.parentNode.parentNode.children[2].textContent; el.addEventListener('click', function() &#123; lovedStores.push(lovedStoreTel); el.classList.toggle('hide'); el.parentNode.children[2].classList.toggle('show'); localStorage.setItem('lovedStores', JSON.stringify(lovedStores)) ; &#125;) &#125;) loved.forEach(el =&gt; &#123; const lovedStoreTel = el.parentNode.parentNode.children[2].textContent; el.addEventListener('click', function() &#123; removeByValue(lovedStores, lovedStoreTel); el.classList.toggle('show'); el.parentNode.children[1].classList.toggle('hide'); localStorage.setItem('lovedStores', JSON.stringify(lovedStores)) ; &#125;) &#125;)&#125; 後記約莫二月初的時候，我在前端社群看到有人使用中國丁香園所蒐集的資料來視覺化 COVID-19（武漢肺炎） 的疫情狀況，就覺得很有趣，也想要試看看。沒想到幾天後政府提出實名制購買口罩的政策，數位政委唐鳳旋即宣布將在 2 月 6 日釋出 API 供技術社群開發應用。所以，前一天晚上我便將地圖和網頁架構寫好， 6 日一早串上 API ，將熱點視覺化後，旋即分享給身旁的朋友，再慢慢優化功能與介面。等未來框架學得差不多，也會試著以框架重新搭建一次。 其實過程中，除了技術的學習以外，最感動的莫過於技術社群和政府部門協力參與開發的能量，無論是 Web 、 APP 還是聊天機器人，各式各樣的應用服務讓我深刻感受 Hackers 在短時間內嘗試透過技術解決問題的熱忱。這也讓我更加相信學習程式設計的目的，是以人為本地解決問題，進而對社會產生貢獻。 期望我能保持這樣的心，繼續精進，成為理想中的 Contributor 。**** 參考資料 口罩供需資訊平台 從Promise開始的JavaScript異步生活 六角學院－Leaflet + OpenStreetMap 地圖應用開發","link":"/2020/02/15/mask-map-share/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"SVG","slug":"SVG","link":"/tags/SVG/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"Data-visualization","slug":"Data-visualization","link":"/tags/Data-visualization/"}],"categories":[{"name":"Others","slug":"Others","link":"/categories/Others/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"weird-JavaScript","slug":"weird-JavaScript","link":"/categories/weird-JavaScript/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"JS-Underground-City","slug":"JS-Underground-City","link":"/categories/JS-Underground-City/"},{"name":"Side-project","slug":"Side-project","link":"/categories/Side-project/"}]}